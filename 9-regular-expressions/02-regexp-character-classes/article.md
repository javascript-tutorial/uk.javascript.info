# Character classes

Розглянемо практичне завдання -- у нас є номер телефону типу `"+1(703)-123-45-67"`, і нам потрібно перетворити його на рядок тільки з чисел: `17031234567`.

Для цього ми можемо знайти та видалити все, що не є числом. Із цим нам допоможуть символьні класи.

*Символьний клас* -- це спеціальне позначення, яке відповідає будь-якому символу з певного набору.

Для початку давайте розглянемо клас "цифра". Він позначається як `pattern:\d` і відповідає "будь-якій одній цифрі".

Наприклад, знайдемо першу цифру в номері телефону:

```js run
let str = "+1(703)-123-45-67";

let regexp = /\d/;

alert( str.match(regexp) ); // 1
```

Без прапора `pattern:g` регулярний вираз шукає лише перший збіг, тобто першу цифру `pattern:\d`.

Давайте додамо прапор `pattern:g`, щоб знайти всі цифри:

```js run
let str = "+1(703)-123-45-67";

let regexp = /\d/g;

alert( str.match(regexp) ); // масив збігів: 1,7,0,3,1,2,3,4,5,6,7

// давайте зробимо з них номер телефону лише з цифр:
alert( str.match(regexp).join('') ); // 17031234567
```

Це був символьний клас для цифр. Є й інші символьні класи.

Найбільш використовувані:

`pattern:\d` ("d" від англійского "digit" означає "цифра")
: Цифра: символ від `0` до `9`.

`pattern:\s` ("s" від англійского "space" означає "пробіл")
: Пробільні символи: включає символ пробілу, табуляції `\t`, перенесення рядка `\n` і деякі інші рідкісні пробілові символи, що позначаються як `\v`, `\f` і `\r`.

`pattern:\w` ("w" від англійского "word" означає "слово")
: Символ "слова" -- літера латинського алфавіту, цифра або символ підкреслення `_`. Нелатинські літери (наприклад, кирилиця чи хінді) не належать до `pattern:\w`.

Наприклад, `pattern:\d\s\w` означає "цифру", за якою йде "символ пробілу", після якого йде "символ слова", наприклад `match:1 a`.

**Регулярний вираз може містити як звичайні символи, так і символьні класи.**

Наприклад, `pattern:CSS\d` відповідає рядку `match:CSS` із цифрою після нього:

```js run
let str = "Чи існує CSS4?";
let regexp = /CSS\d/

alert( str.match(regexp) ); // CSS4
```

Також ми можемо використовувати багато символьних класів:

```js run
alert( "I love HTML5!".match(/\s\w\w\w\w\d/) ); // ' HTML5'
```

Відповідність (кожному символьному класу відповідає один символ результату):

![](love-html5-classes.svg)

## Зворотні символьні класи

Для кожного символьного класу існує "зворотній клас", що позначається тією ж літерою, але у верхньому регістрі.

"Зворотній" означає, що він відповідає всім іншим символам, наприклад:

`pattern:\D`
: Не цифра: будь-який символ, окрім `pattern:\d`, наприклад, літера.

`pattern:\S`
: Не пробіл: будь-який символ, окрім `pattern:\s`, наприклад, літера.

`pattern:\W`
: Будь-який символ, окрім `pattern:\w`, тобто не букви з латиниці, не символ підкреслення і цифра.

На початку розділу ми бачили, як створити номер телефону з рядка виду `subject:+1(703)-123-45-67`: знайти всі цифри та з'єднати їх.

```js run
let str = "+1(703)-123-45-67";

alert( str.match(/\d/g).join('') ); // 17031234567
```

Альтернативний, коротший шлях -- знайти нецифрові символи `pattern:\D` і видалити їх з рядка:

```js run
let str = "+1(703)-123-45-67";

alert( str.replace(/\D/g, "") ); // 17031234567
```

## Крапка -- це будь-який символ

Крапка `pattern:.` -- це спеціальний символьний клас, який відповідає "будь-якому символу, крім символу нового рядка".

Наприклад:

```js run
alert( "Y".match(/./) ); // Y
```

Або в середині регулярного виразу:

```js run
let regexp = /CS.4/;

alert( "CSS4".match(regexp) ); // CSS4
alert( "CS-4".match(regexp) ); // CS-4
alert( "CS 4".match(regexp) ); // CS 4 (пробіл також є символом)
```

Зверніть увагу, що точка означає "будь-який символ", але не "відсутність символу". Там має бути будь-який символ, щоб відповідати умові пошуку:

```js run
alert( "CS4".match(/CS.4/) ); // null, немає збігів тому що немає символу для точки
```

### Крапка, як буквально будь-який символ із прапорцем "s".

За замовчуванням крапка не відповідає символу нового рядка `\n`.

Наприклад, регулярний вираз `pattern:A.B` відповідає `match:A`, а потім `match:B` з будь-яким символом між ними, крім символу нового рядка `\n`:

```js run
alert( "A\nB".match(/A.B/) ); // null (немає збігів)
```

Є багато ситуацій, коли ми хотіли б, щоб крапка означала буквально "будь-який символ", включаючи новий рядок.

Ось що робить прапор `pattern:s`. Якщо регулярний вираз містить його, то крапка `pattern:.` відповідає буквально будь-якому символу:

```js run
alert( "A\nB".match(/A.B/s) ); // A\nB (збіг!)
```

````warn header="Не підтримується в IE"
Прапор `pattern:s` не підтримується в IE.

На щастя, є альтернатива, яка працює всюди. Ми можемо використовувати регулярний вираз, як-от `pattern:[\s\S]`, щоб відповідати "будь-якому символу" (цей шаблон буде описано в статті <info:regexp-character-sets-and-ranges>).

```js run
alert( "A\nB".match(/A[\s\S]B/) ); // A\nB (збіг!)
```

Шаблон `pattern:[\s\S]` буквально говорить: "пробіл АБО не пробіл". Іншими словами, "що завгодно". Ми могли б використати іншу пару додаткових класів, наприклад `pattern:[\d\D]`, це не має значення. Або навіть `pattern:[^]` -- оскільки це означає збіг будь-якого символу, крім нічого.

Також ми можемо використати цей прийом, якщо хочемо, щоб обидва типи "крапок" були в одному шаблоні: наявний шаблон `pattern:.` крапки, який поводиться звичайним чином ("без нового рядка"), а також відповідності "будь-якому символу" з `pattern:[\s\S]` або подібним.
````

````warn header="Зверніть увагу на пробіли"
Зазвичай ми приділяємо мало уваги пробілам. Для нас рядки `subject:1-5` і `subject:1 - 5` майже ідентичні.

Але якщо регулярний вираз не враховує пробіли, він може не спрацювати.

Спробуємо знайти цифри, розділені дефісом:

```js run
alert( "1 - 5".match(/\d-\d/) ); // null, немає збігів!
```

Давайте виправимо це, додавши пробіли в регулярний вираз `pattern:\d - \d`:

```js run
alert( "1 - 5".match(/\d - \d/) ); // 1 - 5, тепер працює
// або ми можемо використати \s клас:
alert( "1 - 5".match(/\d\s-\s\d/) ); // 1 - 5, також працює
```

**Пробіл -- це символ. Так само важливий, як і будь-який інший.**

Ми не можемо додавати або видаляти пробіли в регулярному виразі й сподіватися, що він працюватиме так само.

Іншими словами, у регулярному виразі всі символи мають значення, пробіли також.
````

## Підсумки

Існують такі класи символів:

- `pattern:\d` -- цифри.
- `pattern:\D` -- нецифри.
- `pattern:\s` -- символи пробілів, табуляції, символи нового рядка.
- `pattern:\S` -- усі, крім `pattern:\s`.
- `pattern:\w` -- латинські літери, цифри, підкреслення `'_'`.
- `pattern:\W` -- усі, крім `pattern:\w`.
- `pattern:.` -- будь-який символ, якщо з прапорцем регулярного виразу `'s'`, інакше будь-який, крім символу нового рядка `\n`.

...Але це ще не все!

Кодування Юнікод, яке використовується JavaScript для рядків, надає багато властивостей для символів, наприклад: до якої мови належить літера (якщо це літера), чи це знак пунктуації тощо.

Ми також можемо шукати за цими властивостями. Для цього потрібен прапорець `pattern:u`, який описано в наступній статті.
