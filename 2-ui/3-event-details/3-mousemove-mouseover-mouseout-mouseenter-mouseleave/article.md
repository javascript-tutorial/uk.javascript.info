# Переміщення миші: mouseover/out, mouseenter/leave

Давайте детальніше розглянемо події, які відбуваються, коли вказівник миші переміщається між елементами.

## Події mouseover/mouseout, relatedTarget

Подія `mouseover` виникає, коли вказівник миші наводиться на елемент, а `mouseout` -- коли залишає його.

![](mouseover-mouseout.svg)

Ці події особливі, оскільки мають властивість `relatedTarget`. Ця властивість доповнює `target`. Коли миша йде від одного елемента до іншого, один з них стає `target`, а інший -- `relatedTarget`.

Для `mouseover`:

- `event.target` -- це елемент, на який наведено вказівник миші.
- `event.relatedTarget` -- це елемент, з якого прийшов вказіник (`relatedTarget` -> `target`).

Для `mouseout` навпаки:

- `event.target` -- це елемент, який залишила миша.
- `event.relatedTarget` -- це новий елемент під вказівником, на який перейшла миша (`target` -> `relatedTarget`).

```online
У наведеному нижче прикладі кожне обличчя та його риси є окремими елементами. Коли ви рухаєте мишею, події миші відображаються в текстовій області.

Кожна подія містить інформацію як про `target`, так і про `relatedTarget`:

[codetabs src="mouseoverout" height=280]
```

```warn header="`relatedTarget` може бути `null`"
Властивість `relatedTarget` може мати значення `null`.

Це нормально і просто означає, що вказівник миші прийшов не з іншого елемента, а десь з вікна. Або навпаки, що вказівник вийшов за межі вікна браузера.

Нам варто пам'ятати про цю можливість, використовуючи `event.relatedTarget` в коді. Бо якщо спробувати отримати доступ до `event.relatedTarget.tagName`, то виникне помилка.
```

## Пропуск елементів

Подія `mousemove` запускається, коли миша рухається. Але це не означає, що кожен навіть найменший рух веде до окремої події.

Час від часу браузер перевіряє положення миші. І якщо він помічає зміни, то запускає події.

Це означає, що якщо користувач рухає мишею дуже швидко, деякі DOM-елементи можуть бути пропущені:

![](mouseover-mouseout-over-elems.svg)

Якщо миша дуже швидко рухається від елементів `#FROM` до `#TO`, як зазначено вище, то проміжні елементи `<div>` (або деякі з них) можуть бути пропущені. Подія `mouseout` може бути ініційована на `#FROM`, а потім одразу `mouseover`на `#TO`.

Це добре для продуктивності, бо може бути багато проміжних елементів. Ми насправді не хочемо обробляти кожен із них.

З іншого боку, ми повинні мати на увазі, що вказівник миші не "відвідує" всі елементи на шляху і може "стрибати".

Зокрема, можливо, що вказівник стрибне прямо всередину сторінки з поза меж вікна. У цьому випадку `relatedTarget` має значення `null`, тому що він прийшов "нізвідки":

![](mouseover-mouseout-from-outside.svg)

```online
Ви можете перевірити це на тестовому стенді нижче.

Його HTML має два вкладені елементи: `<div id="child">` знаходиться всередині `<div id="parent">`. Якщо ви швидко наведете на них мишу, то, можливо, лише дочірній div ініціює події, або батьківський, або навіть подій не буде взагалі.

Також перемістіть вказівник у дочірній `div`, а потім швидко перемістіть його вниз через батьківський. Якщо рух досить швидкий, то батьківський елемент ігнорується. Миша перетне батьківський елемент, не помітивши цього.

[codetabs height=360 src="mouseoverout-fast"]
```

```smart header="If `Якщо спрацьовує `mouseover`, має бути `mouseout`"
У разі швидких рухів миші проміжні елементи можуть ігноруватися, але одне ми знаємо напевно: якщо вказівник "офіційно" увійшов на елемент (генерується подія `mouseover`), то при виході з нього ми завжди отримуємо `mouseout`.
```

## Mouseout при переході на дочірній елемент

Важлива функція події `mouseout` -- вона запускається, коли вказівник переміщується від елемента до його нащадка, наприклад, від `#parent` до `#child` у HTML нижче:

```html
<div id="parent">
  <div id="child">...</div>
</div>
```

Якщо ми знаходимося на `#parent`, а потім переміщуємо вказівник глибше в `#child`, ми отримуємо `mouseout` на `#parent`!

![](mouseover-to-child.svg)

Це може здатися дивним, але це легко пояснити.

**Відповідно до логіки браузера, вказівник миші може бути лише над *одним* елементом у будь-який момент часу -- найбільш вкладеним і верхнім за z-індексом.**

Отже, якщо він переходить до іншого елемента (навіть до нащадка), то він залишає попередній.

Зверніть увагу на ще одну важливу деталь обробки подій.

Подія `mouseover` на нащадку буде спливати. Отже, якщо `#parent` має обробник `mouseover`, він спрацює:

![](mouseover-bubble-nested.svg)

```online
Ви можете це добре побачити в прикладі нижче: `<div id="child">` знаходиться всередині `<div id="parent">`. І обробники `mouseover/out` для елементу `#parent` виведуть деталі події.

Якщо ви перемістите вказівник миші від `#parent` до `#child`, це викличе дві події на `#parent`:
1. `mouseout [target: parent]` (вказівник залишив parent), далі
2. `mouseover [target: child]` (дійшов до child, спливання події).

[codetabs height=360 src="mouseoverout-child"]
```

Як показано, коли вказівник переміщується від елемента `#parent` до `#child`, на батьківському елементі запускаються два обробники: `mouseout` і `mouseover`:

```js
parent.onmouseout = function(event) {
  /* event.target: parent елемент */
};
parent.onmouseover = function(event) {
  /* event.target: child елемент (спливання) */
};
```

**Якщо ми не перевіримо `event.target` всередині обробників, то може здатися, що вказівник миші залишив елемент `#parent`, а потім одразу повернувся на нього.**

Але це не так! Вказівник все ще знаходиться над батьківським елементом, він просто перемістився глибше на дочірній елемент.

Якщо є якісь дії після виходу з батьківського елемента, напр. анімація запускається в `parent.onmouseout`, ми зазвичай не хочемо цього, коли вказівник просто йде глибше в `#parent`.

Щоб уникнути цього, ми можемо перевірити `relatedTarget` в обробнику і, якщо вказівник все ще всередині елемента, ігнорувати цю подію.

Як альтернативу ми можемо використовувати інші події: `mouseenter` і `mouseleave`, які ми зараз розглянемо, оскільки вони не мають таких проблем.

## Події mouseenter і mouseleave

Події `mouseenter/mouseleave` схожі на `mouseover/mouseout`. Вони спрацьовують, коли вказівник миші входить або залишає елемент.

Але є дві важливі відмінності:

1. Переходи всередині елемента до/від нащадків не враховуються.
2. Події `mouseenter/mouseleave` не спливають.

Ці події надзвичайно прості.

Коли вказівник входить на елемент, спрацьовує `mouseenter`. Точне розташування вказівника всередині елемента або його нащадків не має значення.

Коли вказівник залишає елемент, спрацьовує `mouseleave`.

```online
Цей приклад подібний до наведеного вище, але тепер у верхньому елементі є `mouseenter/mouseleave` замість `mouseover/mouseout`.

Як бачите, єдині генеровані події пов’язані з переміщенням вказівника в верхній елемент і з нього. Нічого не відбувається, коли покажчик йде до дочірнього елемента і назад. Переходи між нащадками ігноруються

[codetabs height=340 src="mouseleave"]
```

## Делегування подій (Event delegation)

Події `mouseenter/leave` дуже прості та легкі у використанні. Але вони не спливають. Тому ми не можемо використовувати з ними делегування подій (event delegation).

Уявіть, що ми хочемо керувати входом/виходом вказівника миші для клітинок таблиці, в якій сотні клітин.

Ефективним рішенням було б встановити обробник на `<table>` і обробляти події там. Але `mouseenter/leave` не спливають. Отже, якщо така подія відбувається на `<td>`, то лише обробник на цьому `<td>` може її перехопити.

Обробники для `mouseenter/leave` на `<table>` запускаються лише тоді, коли вказівник входить/виходить із таблиці в цілому. Інформацію про переходи всередині нього отримати неможливо.

Отже, давайте використаємо `mouseover/mouseout`.

Почнемо з простих обробників, які підсвічують елемент під вказіником миші:

```js
// виділимо елемент під вказівником
table.onmouseover = function(event) {
  let target = event.target;
  target.style.background = 'pink';
};

table.onmouseout = function(event) {
  let target = event.target;
  target.style.background = '';
};
```

```online
Ось вони в дії. Коли миша переміщається по елементах цієї таблиці, поточний виділяється:

[codetabs height=480 src="mouseenter-mouseleave-delegation"]
```

У нашому випадку ми хочемо обробляти переходи між клітинами таблиці `<td>`: вхід у клітину та вихід з неї. Інші переходи, як всередині клітини або за її межами, нас не цікавлять. Відфільтруємо їх.

Ось що ми можемо зробити:

- Запам’ятайте поточний виділений `<td>` у змінній, назвемо її `currentElem`.
- При `mouseover` -- ігноруємо, якщо ми все ще перебуваємо всередині поточного `<td>`.
- При `mouseout` -- ігноруємо, якщо ми не залишили поточний `<td>`.

Ось приклад коду, який враховує всі можливі ситуації:

[js src="mouseenter-mouseleave-delegation-2/script.js"]

І ще раз про важливі особливості такого підходу:
1. Ми використовуємо делегування подій для обробки входу/виходу вказівника на будь-який `<td>` всередині таблиці. Таким чином, ми покладаємося на `mouseover/out` замість `mouseenter/leave`, які не спливають і, отже, не дозволяють делегування.
2. Додаткові події, такі як переміщення між нащадками `<td>`, відфільтровуються, тому `onEnter/Leave` запускається, лише якщо вказівник залишає або входить на `<td>`.

```online
Ось повний приклад з усіма деталями:

[codetabs height=460 src="mouseenter-mouseleave-delegation-2"]

Спробуйте перемістити курсор у клітини таблиці та всередину них. Швидко чи повільно -- не має значення. На відміну від попереднього прикладу, виділено лише `<td>`.
```

## Підсумки

Ми розглянули події `mouseover`, `mouseout`, `mousemove`, `mouseenter` і `mouseleave`.

Варто звернути увагу на такі речі:

- Швидкий рух миші може призвести до пропуску проміжних елементів.
- Події `mouseover/out` і `mouseenter/leave` мають додаткову властивість: `relatedTarget`. Це елемент, до/від якого ми йдемо, доповнюючи `target`.

Події `mouseover/out` запускаються, навіть коли ми переходимо від батьківського елемента до дочірнього. Браузер припускає, що вказівник миші може одночасно перебувати лише над одним елементом -- найглибшим.

Події `mouseenter/leave` відрізняються в цьому аспекті: вони запускаються лише тоді, коли вказівник миші входить і виходить з елемента в цілому. І ще вони не спливають.
