# Події миші

У цьому розділі ми докладніше розглянемо події миші та їх властивості.

Зверніть увагу: подібні події можуть надходити не тільки від миші, але й з інших пристроїв, таких як телефони та планшети, де вони емулюються для сумісності.

## Типи подій миші

Ми вже бачили деякі з цих подій:

`mousedown/mouseup`
: Клікання/відпускання кнопки миші над елементом.

`mouseover/mouseout`
: Курсор заходить/виходить з елемента.

`mousemove`
: Кожне переміщення миші над елементом викликає цю подію.

`click`
: Спрацьовує після `mousedown`, а потім `mouseup` над тим же елементом, якщо була використана ліва кнопка миші.

`dblclick`
: Спрацьовує після двох кліків на одному елементі за короткий проміжок часу. На сьогоднішній день рідко використовується.

`contextmenu`
: Спрацьовує при натисканні правої кнопки миші. Є й інші способи відкрити контекстне меню, напр. за допомогою спеціальної клавіші на клавіатурі також спрацьовує, але це вже не зовсім подія миші.

...Також існують кілька інших подій, про них ми розповімо пізніше.

## Порядок подій

Як ви можете бачити зі списку вище, дія користувача може викликати безліч подій.

Наприклад, клік лівою кнопкою спочатку ініціює `mousedown`, коли кнопку натиснуто, потім `mouseup` і `click`, коли її відпускають.

У випадках, коли одна дія ініціює декілька подій, їх порядок фіксується. Тобто обробники викликаються в порядку `mousedown` -> `mouseup` -> `click`.

```online
Клікніть кнопку нижче, і ви побачите події. Спробуйте також клікнути двічі.

Всі події миші реєструються у тестовому вікні нижче, і якщо між ними є затримка більше 1 секунди, вони розділяються горизонтальною лінією.

Також ми можемо побачити властивість `button`, яка дозволяє виявити яку саме кнопку миші клікнули, це пояснюється нижче.

<input onmousedown="return logMouse(event)" onmouseup="return logMouse(event)" onclick="return logMouse(event)" oncontextmenu="return logMouse(event)" ondblclick="return logMouse(event)" value="Click me with the right or the left mouse button" type="button"> <input onclick="logClear('test')" value="Clear" type="button"> <form id="testform" name="testform"> <textarea style="font-size:12px;height:150px;width:360px;"></textarea></form>
```

## Кнопка миші

Події, пов’язані з кліками, завжди мають властивість `button`, що дозволяє отримати точну кнопку миші.

Зазвичай ми не використовуємо її для подій `click` і `contextmenu`, оскільки перше відбувається лише при натисканні лівою кнопкою миші, а останнє -- лише при натисканні правою кнопкою миші.

З іншого боку, обробникам `mousedown` та `mouseup` може знадобитися `event.button`, тому що ці події запускаються на будь-якій кнопці, тому `button` дозволяє розрізняти "праву кнопку миші" та "ліву кнопку миші".

Можливі значення `event.button`:

| Стан кнопки | `event.button` |
|--------------|----------------|
| Ліва кнопка (основна) | 0 |
| Середня кнопка (допоміжна) | 1 |
| Права кнопка (другорядна) | 2 |
| Кнопка X1 (назад) | 3 |
| Кнопка X2 (вперед) | 4 |

Більшість пристроїв мають лише ліву та праву кнопки, тому можливі значення `0` або `2`. Сенсорні пристрої також генерують подібні події, коли на них натискають.

Також є властивість `event.buttons`, яка містить усі натиснуті кнопки як ціле число, по одному біту на кнопку. На практиці ця властивість використовується дуже рідко, деталі можна знайти на сторінці [MDN](mdn:/api/MouseEvent/buttons), якщо вона вам колись знадобиться.

```warn header="Застаріла властивість `event.which`"
Старий код може використовувати властивість `event.which`, що є старим нестандартним способом отримання кнопки з можливими значеннями:

- `event.which == 1` – ліва кнопка,
- `event.which == 2` – середня кнопка,
- `event.which == 3` – права кнопка.

На даний момент властивість `event.which` застала, ми не повинні її використовувати.
```

## Модифікатори: shift, alt, ctrl і meta

Усі події миші містять інформацію про натиснуті клавіші-модифікатори.

Властивості події:

- `shiftKey`: `key:Shift`
- `altKey`: `key:Alt` (чи `key:Opt` для Mac)
- `ctrlKey`: `key:Ctrl`
- `metaKey`: `key:Cmd` для Mac

Вони мають значення'true', якщо відповідна клавіша була натиснута під час події.

Наприклад, кнопка нижче працює лише на `key:Alt+Shift» + клік:

```html autorun height=60
<button id="button">Alt+Shift+Клікни мене!</button>

<script>
  button.onclick = function(event) {
*!*
    if (event.altKey && event.shiftKey) {
*/!*
      alert('Ура!');
    }
  };
</script>
```

```warn header="Увага: на Mac зазвичай `Cmd` замість `Ctrl`"
На Windows і Linux є клавіші-модифікатори `key:Alt`, `key:Shift` і `key:Ctrl`. На Mac є ще одна: `key:Cmd`, що відповідає властивості `metaKey`.

У більшості застосунків, коли Windows/Linux використовує `key:Ctrl`, на Mac використовується `key:Command`.

Тобто: коли користувач Windows натискає `key:Ctrl+Enter` або `key:Ctrl+A`, користувач Mac натискає `key:Cmd+Enter` або `key:Cmd+A`, і так далі.

Отже, якщо ми хочемо підтримувати такі комбінації, як `key:Ctrl`+ клік, то для Mac має сенс використовувати `key:Cmd`+ клік. Це зручніше для користувачів Mac.

Навіть якщо ми б хотіли змусити користувачів Mac застосувати `key:Ctrl`+ клік -- це трохи складно. Проблема полягає в тому, що клік лівою кнопкою миші за допомогою `key:Ctrl` інтерпретується як *клік правою кнопкою миші* у MacOS, і він генерує подію `contextmenu`, а не `click`, як Windows/Linux.

Тож якщо ми хочемо, щоб користувачі всіх операційних систем відчували себе комфортно, то разом із `ctrlKey` ми повинні перевірити `metaKey`.

Для JS-коду це означає, що ми повинні перевірити `if (event.ctrlKey || event.metaKey)`.
```

```warn header="Є також мобільні пристрої"
Комбінації клавіатури хороші як доповнення до робочого процесу. Так що якщо відвідувач використовує клавіатуру - вони працюють.

Але якщо в їхньому пристрої цього немає - то має бути спосіб жити без клавіш-модифікаторів.
```

## Координати: clientX/Y, pageX/Y

Усі події миші надають координати у двох варіантах:

1. Відносно Window: `clientX` та `clientY`.
2. Відносно Document: `pageX` та `pageY`.

Ми вже розглянули різницю між ними у розділі <info:coordinates>.

Коротше кажучи, відносні до документа координати `pageX/Y` відраховуються від лівого верхнього кута документа і не змінюються під час прокручування сторінки, тоді як `clientX/Y` відраховуються від лівого верхнього кута поточного вікна. Коли сторінка прокручується, вони змінюються.

Наприклад, якщо у нас є вікно розміром 500x500, а миша знаходиться в лівому верхньому куті, то `clientX` і `clientY` дорівнюють `0`, незалежно від того, як прокручується сторінка.

А якщо миша знаходиться в центрі, то `clientX` і `clientY` дорівнюють `250`, незалежно від того, яке місце в документі це. У цьому аспекті вони схожі на `position:fixed`.

````online
Наведіть курсор миші на поле введення, щоб побачити `clientX/clientY` (приклад знаходиться в `iframe`, тому координати є відносно цього `iframe`):

```html autorun height=50
<input onmousemove="this.value=event.clientX+':'+event.clientY" value="Наведіть курсор на мене">
```
````

## Запобігання виділення при наведенні миші

Подвійний клік миші має побічний ефект, який може створювати незручності в деяких інтерфейсах: він виділяє текст.

Наприклад, подвійний клік на тексті нижче виділяє його на додаток до нашого обробника:

```html autorun height=50
<span ondblclick="alert('dblclick')">Клікни мене двічі</span>
```

Якщо натиснути ліву кнопку миші і, не відпускаючи її, пересунути, це також додасть виділення, часто небажане.

Існує кілька способів запобігти виділенню, про які ви можете прочитати в розділі <info:selection-range>.

У цьому конкретному випадку найрозумнішим способом є запобігання дії браузера на `mousedown`. Таким чином ми запобігнемо двом виділенням:

```html autorun height=50
До...
<b ondblclick="alert('Клік!')" *!*onmousedown="return false"*/!*>
  Клікни мене двічі
</b>
...Після
```

Тепер виділений жирним елемент не виділяється подвійними кліком, і натискання на ньому лівої кнопки не почне виділення.

Зверніть увагу: текст всередині нього все ще можна виділити. Однак виділення слід починати не з самого тексту, а до або після нього. Зазвичай, це нормально сприймається користувачами.

````smart header="Запобігання копіювання"
Якщо ми хочемо вимкнути виділення, щоб захистити вміст нашої сторінки від копіювання, ми можемо використовувати іншу подію: `oncopy`.

```html autorun height=80 no-beautify
<div *!*oncopy="alert('Копіювання заборонено!');return false"*/!*>
  Шановний користувач,
  Копіювання заборонено.
  Якщо ви знаєте JS або HTML, ви можете отримати все з джерела сторінки.
</div>
```
Якщо ви спробуєте скопіювати фрагмент тексту в `<div>`, це не спрацює, оскільки типову дію `oncopy` заборонено.

Безумовно, користувач має доступ до HTML-джерела сторінки, і може взяти звідти вміст, але не всі знають, як це зробити.
````

## Підсумки

Події миші мають такі властивості:

- Кнопка: `button`.
- Клавіші-модифікатори (`true`, якщо їх натиснути): `altKey`, `ctrlKey`, `shiftKey` і `metaKey` (Mac).
  - Якщо ви хочете працювати з `key:Ctrl`, то не забувайте про користувачів Mac, вони зазвичай використовують `key:Cmd`, тому краще перевірити `if (e.metaKey || e.ctrlKey)`.

- Координати відносно Window: `clientX/clientY`.
- Координати відносно Document: `pageX/pageY`.

Типова дія браузера `mousedown` - виділення тексту, якщо в інтерфейсі воно швидше заважає, йому слід запобігти.

У наступному розділі ми дізнаємось більше деталей про події, які слідують за рухом курсора, і про те, як відстежувати зміни елементів під ним.
