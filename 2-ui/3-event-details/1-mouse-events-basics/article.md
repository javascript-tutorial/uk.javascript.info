# Події миші

У цьому розділі ми докладніше розглянемо події миші та їх властивості.

Зверніть увагу: подібні події можуть надходити не тільки від миші, але й з інших пристроїв, таких як телефони та планшети, де вони емулюються для сумісності.

## Типи подій миші

Ми вже бачили деякі з цих подій:

`mousedown/mouseup`
: Клікання/відпускання кнопки миші над елементом.

`mouseover/mouseout`
: Курсор заходить/виходить з елемента.

`mousemove`
: Кожне переміщення миші над елементом викликає цю подію.

`click`
: Спрацьовує після `mousedown`, а потім `mouseup` над тим же елементом, якщо була використана ліва кнопка миші.

`dblclick`
: Спрацьовує після двох кліків на одному елементі за короткий проміжок часу. На сьогоднішній день рідко використовується.

`contextmenu`
: Спрацьовує при натисканні правої кнопки миші. Є й інші способи відкрити контекстне меню, напр. за допомогою спеціальної клавіші на клавіатурі, але це вже не зовсім подія миші.

...Також існують кілька інших подій, про них ми розповімо пізніше.

## Порядок подій

Як ви можете бачити зі списку вище, дія користувача може викликати безліч подій.

Наприклад, клік лівою кнопкою спочатку ініціює `mousedown`, коли кнопку натиснуто, потім `mouseup` і `click`, коли її відпускають.

У випадках, коли одна дія ініціює декілька подій, їх порядок фіксується. Тобто обробники викликаються в порядку `mousedown` -> `mouseup` -> `click`.

```online
Клікніть кнопку нижче, і ви побачите події. Спробуйте також клікнути двічі.

Всі події миші реєструються у тестовому вікні нижче, і якщо між ними є затримка більше 1 секунди, вони розділяються горизонтальною лінією.

Також ми можемо побачити властивість `button`, яка дозволяє виявити яку саме кнопку миші клікнули, це пояснюється нижче.

<input onmousedown="return logMouse(event)" onmouseup="return logMouse(event)" onclick="return logMouse(event)" oncontextmenu="return logMouse(event)" ondblclick="return logMouse(event)" value="Click me with the right or the left mouse button" type="button"> <input onclick="logClear('test')" value="Clear" type="button"> <form id="testform" name="testform"> <textarea style="font-size:12px;height:150px;width:360px;"></textarea></form>
```

## Кнопка миші

Події, пов’язані з кліками, завжди мають властивість `button`, що дозволяє отримати точну кнопку миші.

Зазвичай ми не використовуємо її для подій `click` і `contextmenu`, оскільки перше відбувається лише при натисканні лівою кнопкою миші, а останнє -- лише при натисканні правою кнопкою миші.

З іншого боку, обробникам `mousedown` та `mouseup` може знадобитися `event.button`, тому що ці події запускаються на будь-якій кнопці, тому `button` дозволяє розрізняти "праву кнопку миші" та "ліву кнопку миші".

Можливі значення `event.button`:

| Стан кнопки | `event.button` |
|--------------|----------------|
| Ліва кнопка (основна) | 0 |
| Середня кнопка (допоміжна) | 1 |
| Права кнопка (другорядна) | 2 |
| Кнопка X1 (назад) | 3 |
| Кнопка X2 (вперед) | 4 |

Більшість пристроїв мають лише ліву та праву кнопки, тому можливі значення `0` або `2`. Сенсорні пристрої також генерують подібні події, коли на них натискають.

Також є властивість `event.buttons`, яка містить усі натиснуті кнопки як ціле число, по одному біту на кнопку. На практиці ця властивість використовується дуже рідко, деталі можна знайти на сторінці [MDN](mdn:/api/MouseEvent/buttons), якщо вона вам колись знадобиться.

```warn header="Застаріла властивість `event.which`"
Старий код може використовувати властивість `event.which`, що є застарілим нестандартним способом отримання кнопки з можливими значеннями:

- `event.which == 1` – ліва кнопка,
- `event.which == 2` – середня кнопка,
- `event.which == 3` – права кнопка.

На даний момент властивість `event.which` застаріла, ми не повинні її використовувати.
```

## Модифікатори: shift, alt, ctrl і meta

Усі події миші містять інформацію про натиснуті клавіші-модифікатори.

Властивості події:

- `shiftKey`: `key:Shift`
- `altKey`: `key:Alt` (чи `key:Opt` для Mac)
- `ctrlKey`: `key:Ctrl`
- `metaKey`: `key:Cmd` для Mac

Вони мають значення `true`, якщо відповідна клавіша була натиснута під час події.

Наприклад, кнопка нижче працює лише на `key:Alt+Shift` + клік:

```html autorun height=60
<button id="button">Alt+Shift+Клікни мене!</button>

<script>
  button.onclick = function(event) {
*!*
    if (event.altKey && event.shiftKey) {
*/!*
      alert('Ура!');
    }
  };
</script>
```

```warn header="Увага: на Mac зазвичай `Cmd` замість `Ctrl`"
На Windows і Linux є клавіші-модифікатори `key:Alt`, `key:Shift` і `key:Ctrl`. На Mac є ще одна: `key:Cmd`, що відповідає властивості `metaKey`.

У більшості застосунків, коли Windows/Linux використовує `key:Ctrl`, на Mac використовується `key:Command`.

Тобто: коли користувач Windows натискає `key:Ctrl+Enter` або `key:Ctrl+A`, користувач Mac натискає `key:Cmd+Enter` або `key:Cmd+A`, і так далі.

Отже, якщо ми хочемо підтримувати такі комбінації, як `key:Ctrl`+ клік, то для Mac має сенс використовувати `key:Cmd`+ клік. Це зручніше для користувачів Mac.

Навіть якщо ми б хотіли змусити користувачів Mac застосувати `key:Ctrl`+ клік -- це трохи складно. Проблема полягає в тому, що клік лівою кнопкою миші за допомогою `key:Ctrl` інтерпретується як *клік правою кнопкою миші* у MacOS, і він генерує подію `contextmenu`, а не `click`, як Windows/Linux.

Тож якщо ми хочемо, щоб користувачі всіх операційних систем відчували себе комфортно, то разом із `ctrlKey` ми повинні перевірити `metaKey`.

Для JS-коду це означає, що ми повинні перевірити `if (event.ctrlKey || event.metaKey)`.
```

```warn header="Є також мобільні пристрої"
Комбінації клавіатури хороші як доповнення до робочого процесу. Так що якщо відвідувач використовує клавіатуру -- вони працюють.

Але якщо в їхньому пристрої цього немає -- то має бути спосіб жити без клавіш-модифікаторів.
```

## Координати: clientX/Y, pageX/Y

Усі події миші надають координати у двох варіантах:

1. Відносно Window: `clientX` та `clientY`.
2. Відносно Document: `pageX` та `pageY`.

Ми вже розглянули різницю між ними у розділі <info:coordinates>.

Коротше кажучи, відносні до документа координати `pageX/Y` відраховуються від лівого верхнього кута документа і не змінюються під час прокручування сторінки, тоді як `clientX/Y` відраховуються від лівого верхнього кута поточного вікна. Коли сторінка прокручується, вони змінюються.

Наприклад, якщо у нас є вікно розміром 500x500, а миша знаходиться в лівому верхньому куті, то `clientX` і `clientY` дорівнюють `0`, незалежно від того, як прокручується сторінка.

А якщо миша знаходиться в центрі, то `clientX` і `clientY` дорівнюють `250`, незалежно від того, яке місце в документі це. У цьому аспекті вони схожі на `position:fixed`.

````online
Наведіть курсор миші на поле введення, щоб побачити `clientX/clientY` (приклад знаходиться в `iframe`, тому координати є відносно цього `iframe`):

```html autorun height=50
<input onmousemove="this.value=event.clientX+':'+event.clientY" value="Наведіть курсор на мене">
```
````

## Запобігання виділення при наведенні миші

Подвійний клік миші має побічний ефект, який може створювати незручності в деяких інтерфейсах: він виділяє текст.

Наприклад, подвійний клік на тексті нижче виділяє його на додаток до нашого обробника:

```html autorun height=50
<span ondblclick="alert('dblclick')">Клікни мене двічі</span>
```

Якщо натиснути ліву кнопку миші і, не відпускаючи її, пересунути, це також додасть виділення, часто небажане.

Існує кілька способів запобігти виділенню, про які ви можете прочитати в розділі <info:selection-range>.

У цьому конкретному випадку найрозумнішим способом є запобігання дії браузера на `mousedown`. Таким чином ми запобігнемо двом виділенням:

```html autorun height=50
До...
<b ondblclick="alert('Клік!')" *!*onmousedown="return false"*/!*>
  Клікни мене двічі
</b>
...Після
```

Тепер виділений жирним елемент не виділяється подвійними кліком, і натискання на ньому лівої кнопки не почне виділення.

Зверніть увагу: текст всередині нього все ще можна виділити. Однак виділення слід починати не з самого тексту, а до або після нього. Зазвичай, це нормально сприймається користувачами.

````smart header="Запобігання копіювання"
Якщо ми хочемо вимкнути виділення, щоб захистити вміст нашої сторінки від копіювання, ми можемо використовувати іншу подію: `oncopy`.

```html autorun height=80 no-beautify
<div *!*oncopy="alert('Копіювання заборонено!');return false"*/!*>
  Шановний користувач,
  Копіювання заборонено.
  Якщо ви знаєте JS або HTML, ви можете отримати все з джерела сторінки.
</div>
```
Якщо ви спробуєте скопіювати фрагмент тексту в `<div>`, це не спрацює, оскільки типову дію `oncopy` заборонено.

Безумовно, користувач має доступ до HTML-джерела сторінки, і може взяти звідти вміст, але не всі знають, як це зробити.
````

## Підсумки

Події миші мають такі властивості:

- Кнопка: `button`.
- Клавіші-модифікатори (`true`, якщо їх натиснути): `altKey`, `ctrlKey`, `shiftKey` і `metaKey` (Mac).
  - Якщо ви хочете працювати з `key:Ctrl`, то не забувайте про користувачів Mac, вони зазвичай використовують `key:Cmd`, тому краще перевірити `if (e.metaKey || e.ctrlKey)`.

- Координати відносно Window: `clientX/clientY`.
- Координати відносно Document: `pageX/pageY`.

Типова дія браузера `mousedown` -- виділення тексту, якщо в інтерфейсі воно швидше заважає, йому слід запобігти.

У наступному розділі ми дізнаємось більше деталей про події, які слідують за рухом курсора, і про те, як відстежувати зміни елементів під ним.
