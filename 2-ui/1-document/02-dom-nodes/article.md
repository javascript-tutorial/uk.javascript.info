libs:
  - d3
  - domtree

---

# DOM дерево

Основа HTML-документа -- це теги.

Відповідно до моделі об'єкта документа (DOM), кожен HTML-тег є об'єктом. Вкладені теги -- це "діти" всередині батьківського елементу. Текст всередині тегу також є об'єктом.

Всі ці об'єкти доступні за допомогою JavaScript, і ми можемо використовувати їх, щоб змінити сторінку.

Наприклад, `document.body` це об'єкт, що представляє тег `<body>`.

Запуск цього коду зробить `<body>` червоним протягом 3 секунд:

```js run
document.body.style.background = 'red'; // зробити фон червоним

setTimeout(() => document.body.style.background = '', 3000); // поверне назад
```

Тут ми використовували `style.background`, щоб змінити фоновий колір `document.body`, але тут є багато інших властивостей, таких як.

- `innerHTML` -- вміст HTML вузла.
- `offsetWidth` -- ширина вузла (у пікселях)
- ...і так далі.

Незабаром ми дізнаємося більше способів маніпулювати домом, але спочатку потрібно знати його структуру.

## Приклад DOM

Почнемо з наступного простого документа:

```html run no-beautify
<!DOCTYPE HTML>
<html>
<head>
  <title>Про лосів</title>
</head>
<body>
  Правда про лосів.
</body>
</html>
```

DOM представляє HTML як структуру дерева тегів. Ось як це виглядає:

<div class="domtree"></div>

<script>
let node1 = {"name":"HTML","nodeType":1,"children":[{"name":"HEAD","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"\n  "},{"name":"TITLE","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"Про лосів"}]},{"name":"#text","nodeType":3,"content":"\n"}]},{"name":"#text","nodeType":3,"content":"\n"},{"name":"BODY","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"\n  Правда про лосів.\n\n\n"}]}]}

drawHtmlTree(node1, 'div.domtree', 690, 320);
</script>

```online
На зображенні вище, ви можете натиснути на вузли-елементи, а їхні діти будуть відкриватися і закриватися.
```

Кожен дерев'яний вузол є об'єктом.

Теги є *вузлами-елементами* (або просто елементи) і утворюють структуру дерева: `<html>` знаходиться в корені, `<head>` `<body>` - це його дочірні вузли тощо.

Текст всередині елементів утворює *текстові-вузли*, позначені як `#text`. Текстовий вузол містить лише рядок. У нього може не буди нащадків і завжди він завжди є листом дерева.

Наприклад, тег `<title>` має текст `"Про лосів"`.

Зверніть увагу на спеціальні символи в текстових вузлах:

- новий рядок: `↵` (в JavaScript відомий як `\n`)
- пробіл: `␣`

Пробіли та нові рядки є абсолютно діючими символами, як букви та цифри. Вони утворюють текстові вузли і стають частиною DOM. Отже, наприклад, у прикладі вище тег `<head>` містить деякі пробіли перед`<title>`, і цей текст стає `#text` вузлом (він містить лише новий ряд та деякілька пробілів).

Є лише два винятки з цього правила:
1. Пробіли та нові лінії до `<head>` ігноруються з історичних причин.
2. Якщо ми щось помістимо після `<body>`, то це цось автоматично переміщується всередині `body`, в кінці, оскільки специфікація HTML вимагає, що весь вміст повинен бути всередині `<body>`. Отже, після `<body>` не може бути пробілів.

В інших випадках все просто -- якщо є пробіли (так само, як будь-який символ) у документі, то вони стають текстовими вузлами в DOM, і якщо ми їх видалимо, то текстових вузлів там не буде.

Тут немає текстових вузлів з пробілами:

```html no-beautify
<!DOCTYPE HTML>
<html><head><title>Про оленів</title></head><body>Правда про оленів.</body></html>
```

<div class="domtree"></div>

<script>
let node2 = {"name":"HTML","nodeType":1,"children":[{"name":"HEAD","nodeType":1,"children":[{"name":"TITLE","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"Про оленів"}]}]},{"name":"BODY","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"Правда про оленів."}]}]}

drawHtmlTree(node2, 'div.domtree', 690, 210);
</script>

```smart header="Пробіли у рядку на початку/в кінці і ті вузли, що містять тільки пробіли, як правило, приховані в інструментах розробки"
Інструменти браузера (будуть розглянуті скоро), що працюють з DOM, як правило, не показують пробіли на початку/кінці тексту та порожні тексти (переноси рядків) між тегами.

Інструменти розробника зберігають екранний простір таким чином.

На подальших рисунках DOM ми іноді опускаємо їх, коли вони не мають значення. Такі пробіли зазвичай не впливають на те, як відображається документ.
```

## Автокорекція

Якщо браузер зтикається з неправильним HTML, він автоматично виправляє його при створенні DOM.

Наприклад, верхній тег завжди `<html>`. Навіть якщо він не існує у документі, він буде існувати в DOM, тому що браузер створить його. Те ж саме стосується `<body>`.

Як приклад, якщо файл HTML містить єдине слово `"Привіт"`, браузер оберне його в `<html>` and `<body>`, і додасть необхідний `<head>`, а DOM буде виглядати наступним чином:


<div class="domtree"></div>

<script>
let node3 = {"name":"HTML","nodeType":1,"children":[{"name":"HEAD","nodeType":1,"children":[]},{"name":"BODY","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"Привіт"}]}]}

drawHtmlTree(node3, 'div.domtree', 690, 150);
</script>

Під час створення DOM, браузери автоматично обробляють помилки у документі, закривають теги тощо.

Документ з відкритими тегами:

```html no-beautify
<p>Привіт
<li>Мама
<li>і
<li>Тато
```

...стане нормальним DOM, оскільки браузер читає теги та відновлює відсутні частини:

<div class="domtree"></div>

<script>
let node4 = {"name":"HTML","nodeType":1,"children":[{"name":"HEAD","nodeType":1,"children":[]},{"name":"BODY","nodeType":1,"children":[{"name":"P","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"Привіт"}]},{"name":"LI","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"Мама"}]},{"name":"LI","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"і"}]},{"name":"LI","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"Тато"}]}]}]}

drawHtmlTree(node4, 'div.domtree', 690, 360);
</script>

````warn header="Таблиці завжди мають `<tbody>`"
An interesting "special case" is tables. By DOM specification they must have `<tbody>` tag, but HTML text may omit it. Then the browser creates `<tbody>` in the DOM automatically.
Цікавий "особливий випадок" -- це таблиці. Згідно DOM специфікації вони повинні мати тег `<tbody>`, але текст HTML може це пропустити. Тоді браузер створює `<tbody>` у DOM автоматично.

Наприклад, HTML:

```html no-beautify
<table id="table"><tr><td>1</td></tr></table>
```

DOM-структура:
<div class="domtree"></div>

<script>
let node5 = {"name":"TABLE","nodeType":1,"children":[{"name":"TBODY","nodeType":1,"children":[{"name":"TR","nodeType":1,"children":[{"name":"TD","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"1"}]}]}]}]};

drawHtmlTree(node5,  'div.domtree', 600, 200);
</script>

Розумієте? `<tbody>` з'явився з нізвідки. Ми повинні мати це на увазі під час роботи з таблицями, щоб уникнути сюрпризів.
````

## Інші типи вузлів

Окрім елементів та текстових вузлів є деякі інщі типи вузлів.

Наприклад, коментарі:

```html
<!DOCTYPE HTML>
<html>
<body>
  Правда про оленів.
  <ol>
    <li>Олень -- це розумний</li>
*!*
    <!-- comment -->
*/!*
    <li>...та хитрий звір!</li>
  </ol>
</body>
</html>
```

<div class="domtree"></div>

<script>
let node6 = {"name":"HTML","nodeType":1,"children":[{"name":"HEAD","nodeType":1,"children":[]},{"name":"BODY","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"\n  Правда про оленів.\n  "},{"name":"OL","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"\n    "},{"name":"LI","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"Олень -- це розумний"}]},{"name":"#text","nodeType":3,"content":"\n    "},{"name":"#comment","nodeType":8,"content":"comment"},{"name":"#text","nodeType":3,"content":"\n    "},{"name":"LI","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"...і хитрий звір!"}]},{"name":"#text","nodeType":3,"content":"\n  "}]},{"name":"#text","nodeType":3,"content":"\n\n\n"}]}]};

drawHtmlTree(node6, 'div.domtree', 690, 500);
</script>

Тут ми бачимо новий тип вузла дерева -- *вузол-коментар*, позначений як `#comment`, між двома текстовими вузлами.

Ми могли подумати -- чому коментар додається до DOM? Це не впливає на візуальне уявлення. Але є правило - якщо щось є в HTML, то воно також повинно бути в DOM дереві.

**Все в HTML, навіть коментарі, стає частиною DOM.**

Навіть директива `<!DOCTYPE...>` на самому початку HTML також є вузлом DOM. Вона є DOM дереві прямо перед `<html>`. Мало хто знає про це. Ми не збираємося звертатися до цього вузла, ми навіть не малюємо його на діаграмах, але він там.

Об'єкт `document`, який представляє весь документ, формально, також є вузлом DOM.

Існує [12 типів вузлів](https://dom.spec.whatwg.org/#node). На практиці ми зазвичай працюємо з 4-ма з них:

1. `document` -- "пункт входу" в дом.
2. вузли-елементи -- HTML-теги, будівельні блоки дерев.
3. текстові вузли -- містять текст.
4. коментарі -- іноді ми можемо записати туди інформацію, вона не буде показана, але JS може читати її з DOM.

## Поекспериментуйте з цим

Щоб побачити структуру DOM у режимі реального часу, спробуйте [Live Dom Viewer](http://software.hixie.ch/utilities/js/live-dom-viewer/). Просто введіть документ, і внизу відразу з'явиться цого DOM.

Іншим способом вивчення DOM є використання інструментів розробника браузера. Взагалі, це те, що ми використовуємо при розробці.

Для цього відкрийте веб-сторінку [elk.html](elk.html), увімкніть інструменти розробника в браузері та перейдіть на вкладку «Елементи».

Це повинно виглядати так:

![](elk.svg)

Ви можете побачити DOM, натиснути на елементи, переглянути їхні деталі і так далі.

Зверніть увагу, що структура DOM у інструментах розробника спрощується. Текстові вузли показані так само, як текст. І взагалі немає "порожніх" (тільки пробіли) текстових вузлів. Це добре, тому що більшу частину часу ми зацікавлені в вузлах-елементах.

Натискання класу <span class="devtools" style="background-position:-328px -124px"></span> у лівому верхньому куті дозволяє вибрати вузол з веб-сторінки за допомогою миші (або інших пристроїв покажчика) і "Проінспектувати" його (прокрутити до нього на вкладці "Елементи"). Це чудово працює, коли у нас є величезна HTML-сторінка (і відповідний величезний дом) і хотілося би бачити місце конкретного елемента в ньому.

Інший спосіб зробити це -- просто натиснувши праву клавіщу миші на веб-сторінці та вибирати "Inspect" у контекстному меню.

![](inspect.svg)

У правій частині інструментів є наступні підвкладки:
- **Styles** -- ми можемо бачити CSS правила, які застосовано до поточного елемента, включаючи вбудовані правила (сірі). Майже все можна відредагувати на місці, включаючи розміри/марджини/паддінги вікна нижче.
- **Computed** -- для перегляду CSS, що застосовується до елемента за власністю: для кожної власності ми можемо побачити правило, яке дає це (включаючи спадщину CSS та така).
- **Event Listeners** -- щоб побачити слухачів подій, прикріплених до елементів DOM (ми розглянемо їх у наступній частині підручника).
- ...і так далі.

Найкращий спосіб вивчити їх -- натиснути. Більшість значень редагуються на місці.

## Взаємодія з консоллю

Коли ми працюємо з DOM, ми також можемо застосувати до нього JavaScript. Наприклад, отримайти вузол і запустити якийсь код, щоб змінити його так, щоб побачити результат. Ось декілька порад, щоб подорожувати між вкладкою "Елементи" та консоллю.

Для початку:

1. Виберіть першу `<li>` на вкладці елементів.
2. Натисніть `key:Esc` -- це відкриє консоль прямо під вкладкою "Елементи".

Тепер останній вибраний елемент доступний як `$0`, раніше вибраний -- `$1`, тощо.

Ми можемо запустити команди на них. Наприклад, `$0.style.background = 'red'` робить вибраний список елементів червоним, наприклад:

![](domconsole0.svg)

Ось як отримати вузол з елементів у консолі.

Також існує зворотній шлях. Якщо є змінна, що посилається на вузол DOM, то ми можемо використовувати команду `inspect(node)` у консолі, щоб побачити його в панелі елементів.

Або ми можемо просто вивести вузол DOM в консолі та дослідити його "на місці", як і `document.body` нижче:

![](domconsole1.svg)

Звичайно, це для використовується з метою налагодження. З наступної глави ми будемо отримувати доступ та змінювати DOM за допомогою JavaScript.

Інструменти розробника браузера -- є дуже корисними у розробці: ми можемо досліджувати DOM, спробувати різні речі і дивитися, що йде не так.

## Висновки

HTML/XML документ представляється всередині браузера, як дерево DOM.

- Теги стають вузлами-елементами і утворюють структуру.
- Текст стає текстовими вузлами.
- ...і т.д., все, що є в HTML, представлено в DOM, навіть коментарі.

Ми можемо використовувати інструменти розробника, щоб перевіряти DOM та змінювати його вручну.

Тут для початку ми охопили основи та важливі дії, які найбільш часто використовуються. Існує велика документація про інструменти розробника Chrome на <https://developers.google.com/web/tools/chrome-devtools>. Найкращий спосіб дізнатися більше про інструменти розробника -- це відкрити їх та ознайомитися з ними: більшість можливостей очевидні. Пізніше, коли ви загалом розберетеся з ними, читайте документацію, щоб дослідити решту функціоналу.

Вузли DOM мають властивості та методи, які дозволяють нам подорожувати між ними, змінюють їх, переміщуватися по цій сторінці та багато іншого. Ми розберемо їх у наступних розділах.
