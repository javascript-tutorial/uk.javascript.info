# Типи даних

Значення в JavaScript завжди має певний тип даних. Наприклад, рядок або число.

В JavaScript є вісім основних типів даних. В цьому розділі ми розглянемо їх в цілому, а в наступних — детально поговоримо про кожен з них.

Ми можемо призначити змінній будь-який тип даних. Наприклад, в один момент змінна може бути рядком, а в інший - числом:

```js
// тут не буде помилки
let message = "привіт";
message = 123456;
```

Мови програмування, які дозволяють таке робити, називаються "динамічно типізованими". Мається на увазі, що типи даних визначені, але змінні не прив’язанні до жодного типу.

## Число (number)

```js
let n = 123;
n = 12.345;
```

Тип _number_ представляє і цілі числа, і числа з рухомою точкою.

Є багато операцій, що можна робити с числами, наприклад, множення `*`, ділення `/`, додавання `+`, віднімання `-` тощо.

Окрім звичайних чисел, існують так звані "спеціальні числові значення", що також мають відношення до цього типу даних: `Infinity`, `-Infinity` і `NaN`.

- `Infinity` являє собою математичну [нескінченність](https://uk.wikipedia.org/wiki/Нескінченність) ∞. Це спеціальне значення, що є більшим за будь-яке число.

  Ми можемо отримати його як результат ділення на нуль:

  ```js run
  alert(1 / 0); // Infinity
  ```

  Або безпосередньо посилатися на нього:

  ```js run
  alert(Infinity); // Infinity
  ```
- `NaN` (Not a Number) являє собою помилку обчислення. Це є результат неправильної або невизначеної математичної операції, наприклад:

  ```js run
  alert("not a number" / 2); // NaN, таке ділення є помилковим
  ```

  `NaN` є "причепливим" ("заразливим"). Будь-які наступні операції з `NaN` будуть повертати `NaN`:

  ```js run
  alert("not a number" / 2 + 5); // NaN
  ```

  Таким чином, якщо у математичному виразі десь є `NaN`, це значення буде поширюватися на весь результат.

```smart header="Математичні операції є безпечними"
Обчислювання є "безпечним" в JavaScript. Ми можемо робити будь-що: ділити на нуль, звертатися до нечислового рядка як до числа тощо.

Виконання скрипта ніколи не зупиниться з фатальною помилкою (не "вмре"). У найгіршому випадку ми отримаємо в результаті `NaN`.
```

Спеціальні числові значення формально належать до типу "number". Хоча, звісно, вони не є числами у загальноприйнятому розумінні.

Докладніше роботу с числами ми розглянемо у розділі <info:number>.

## BigInt

В JavaScript, тип "number" не може вміщувати числа більші за <code>(2<sup>53</sup>-1)</code> (це `9007199254740991`), або менші за <code>-(2<sup>53</sup>-1)</code> для від’ємних чисел. Це технічне обмеження, викликане їх внутрішньою реалізацією.

Для більшості потреб цього достатньо, але бувають випадки, коли нам потрібні дійсно великі числа, наприклад, для криптографії або мікроксекундних часових міток (timestamps).

Нещодавно в мову був доданий тип `BigInt` для представлення цілих чисел довільної довжини.

Значення з типом `BigInt` створюється шляхом додавання `n` в кінець цілого числа:

```js
// буква "n" в кінці означає, що це число типу BigInt
const bigInt = 1234567890123456789012345678901234567890n;
```

Через те, що тип `BigInt` рідко використовується, ми не розглядатимемо його в цьому розділі, проте ми винесли його в окремий розділ <info:bigint>. Прочитайте його, якщо вам потрібні такі великі числа.


```smart header="Проблеми з сумісністю"
Цієї миті, підтримка типу `BigInt` є в останніх версіях Firefox/Chrome/Edge/Safari з iOS 14, але не в IE.
```

На сайті *MDN* є [таблиця сумісності](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Global_Objects/BigInt#Сумісність_з_веб-переглядачами), де показано, які версії браузерів підтримують тип `BigInt`.

## Рядок (string)

Рядок в JavaScript повинен бути оточений лапками.

```js
let str = "Привіт";
let str2 = 'Одинарні лапки також дозволяються';
let phrase = `так можна вставляти ${str}`;
```

В JavaScript існує три типи лапок.

1. Подвійні лапки: `"Привіт"`.
2. Одинарні лапки: `'Привіт'`.
3. Зворотні лапки: <code>&#96;Привіт&#96;</code>.

Подвійні та одинарні лапки є "звичайними". Тобто немає ніякої різниці, які саме використовувати.

Зворотні лапки є розширенням функціональності. Вони дозволяють вбудовувати змінні та вирази в рядок, обрамляючи їх в `${…}`, наприклад:

```js run
let name = "Іван";

// вбудована змінна
alert(`Привіт, *!*${name}*/!*е!`); // Привіт, Іване!

// вбудований вираз
alert(`результат: *!*${1 + 2}*/!*`); // результат: 3
```

Вираз всередині `${…}` обчислюється, а результат обчислення стає частиною рядка. Ми можемо вбудувати будь-що: змінну `name`, або арифметичний вираз `1 + 2`, або щось набагато складніше.

Будь ласка, зауважте, що вбудовування можна робити тільки зі зворотніми лапками. Інші типи лапок не мають функціональності вбудовування!
```js run
alert("результат: ${1 + 2}"); // результат: ${1 + 2} (подвійні лапки не мають ніякого впливу)
```

Більш детально ми будемо висвітлювати рядки у розділі <info:string>.

```smart header="Не існує типу *символ* (*character*)."
У деяких мовах існує спеціальний тип "character" для позначення єдиного символу. Наприклад, в мовах C та Java це `char`.

В JavaScript не існує такого типу. Є єдиний тип: `string`. Рядок може містити нуль символів (бути пустим), один символ або більше.
```

## Булевий або логічний тип (boolean)

Логічний тип може приймати лише два значення: `true` (істина) та `false` (хиба).

Цей тип зазвичай використовується для зберігання значень так/ні: `true` означає "так, вірно", а `false` означає "ні, не вірно".

Наприклад:

```js
let nameFieldChecked = true; // так, ім’я було перевірене
let ageFieldChecked = false; // ні, вік не був перевіреним
```

Логічне значення також можна отримати як результат порівняння:

```js run
let isGreater = 4 > 1;

alert(isGreater); // true (результат порівняння — "так")
```

Більш глибоко ми охопимо булеві значення у розділі <info:logical-operators>.

## Значення "null"

Спеціальне значення `null` не належить до жодного з описаних вище типів.

Воно формує окремий власний тип, який містить лише значення `null`:

```js
let age = null;
```

В JavaScript `null` не є "посиланням на неіснуючий об’єкт" або "покажчиком на null", як може бути в інших мовах програмування.

Це лише спеціальне значення, яке представляє "нічого", "порожнє" або "невідоме значення".

В наведеному вище коді зазначено, що значення змінної `age` невідоме.

## Значення "undefined"

Спеціальне значення `undefined` також стоїть окремо. Воно представляє власний тип, подібний до "null".

`undefined` означає, що "значення не присвоєно".

Якщо змінна оголошена, але їй не присвоєне якесь значення, тоді значення такої змінної буде `undefined`:

```js run
let age;

alert(age); // покаже "undefined"
```

Технічно, є можливість явно призначити `undefined` змінній:

```js run
let age = 100;

// змінюємо значення на undefined
age = undefined;

alert(age); // "undefined"
```

...Але ми не рекомендуємо так робити. Як правило, ми використовуємо `null`, щоб присвоїти змінній значення "порожнє" або "невідоме", тоді як `undefined` зарезервоване для позначення початкового значення для неприсвоєних речей.

## Об’єкти (object) та символи (symbol)

Тип `object` є особливим типом.

Всі інші типи називаються "примітивами", тому що їх значення можуть містити тільки один елемент (це може бути рядок, число, або будь-що інше). В об’єктах же зберігаються колекції даних і більш складні структури.

Об’єкти є важливою частиною мови, тому ми окремо розглянемо їх в розділі <info:object> після того, як дізнаємося більше про примітиви.

Тип `symbol` використовується для створення унікальних ідентифікаторів в об’єктах. Ми згадали цей тип для повноти, проте детальніше вивчимо його після об’єктів.

## Оператор typeof [#type-typeof]

Оператор `typeof` повертає тип аргументу. Це корисно, коли ми хочемо обробляти значення різних типів по-різному або просто хочемо зробити швидку перевірку.

Він підтримує дві синтаксичні форми:

1. Як оператор: `typeof x`.
2. Як функція: `typeof(x)`.

Інакше кажучи, він працює з дужками або без них. Результат однаковий для обох випадків.

Виклик `typeof x` повертає рядок з назвою типу:

```js
typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

*!*
typeof Math // "object"  (1)
*/!*

*!*
typeof null // "object"  (2)
*/!*

*!*
typeof alert // "function"  (3)
*/!*
```

Останні три рядки можуть потребувати додаткового пояснення:

1. `Math` — це вбудований об’єкт, який забезпечує математичні операції. Ми вивчимо його в розділі <info:number>. Тут він використаний лише як приклад об’єкта.
2. Результатом `typeof null` є `"object"`. Це офіційно визнана помилка в поведінці `typeof`, що існує ще з ранніх днів JavaScript і зберігається для сумісності. Безперечно, `null` не є об’єктом. Це особливе значення з власним типом.
3. Результатом `typeof alert` є `"function"`, тому що `alert` — це функція. Ми будемо вивчати функції в наступних розділах, де ми також побачимо, що в JavaScript немає спеціального типу "function". Функції належать до типу "об’єкт". Але `typeof` трактує їх по-іншому, повертаючи `"function"`. Це також присутнє з ранніх днів JavaScript. Технічно, така поведінка не зовсім правильна, але може бути зручною на практиці.

## Підсумки

В JavaScript існує 8 основних типів.

- `number` для будь-яких чисел: цілих або з рухомою точкою; цілі числа обмежені до <code>±(2<sup>53</sup>-1)</code>.
- `bigint` для цілих чисел довільної довжини.
- `string` для рядків. Рядок може мати нуль або більше символів, немає окремого типу для одного символу.
- `boolean` для `true`/`false`.
- `null` для невідомих значень — автономний тип, який має єдине значення `null`.
- `undefined` для неприсвоєних значень — автономний тип, який має єдине значення `undefined`.
- `object` для більш складних структур даних.
- `symbol` для унікальних ідентифікаторів.

Оператор `typeof` дозволяє нам бачити, який тип зберігається в змінній.

- Дві форми: `typeof x` або `typeof(x)`.
- Повертає рядок з назвою типу, як-от `"string"`.
- Для `null` повертає `"object"` — це помилка в мові, `null` насправді не об’єкт.

В наступних розділах ми зосередимося на примітивних значеннях, а коли ознайомимося з ними, то перейдемо до об’єктів.
