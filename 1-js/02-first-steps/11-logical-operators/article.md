# Логічні оператори

У JavaScript існує три логічні оператори: `||` (АБО), `&&` (І), `!` (НЕ).

Хоча вони називаються "логічними", вони можуть бути застосовані до значень будь-якого типу, не тільки булевих. Їх результати також можуть бути будь-якого типу.

Подивимось більш детально.

## || (АБО)

Оператор "АБО" представлений двома символами вертикальної лінії:

```js
result = a || b;
```

У класичному програмуванні логічний АБО призначений для маніпулювання лише булевими значеннями. Якщо будь-який з його аргументів `true`, він повертає `true`, інакше повертає `false`.

У JavaScript оператор більш складніший і потужніший. Але спочатку подивимося, що відбувається з булевими значеннями.

Є чотири можливі логічні комбінації:

```js run
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
```

Як бачимо, результат завжди `true`, за винятком випадку, коли обидва операнда `false`.

Якщо операнд не є булевим, він перетворюється на булевий для обчислення.

Наприклад, число `1` розглядається як `true`, число `0` — як `false`:

```js run
if (1 || 0) { // працює так само, як ( true || false )
  alert( 'правдиво!' );
}
```

У бильшості випадків АБО `||` використовується в операторі `if`, щоб перевірити, чи є *будь-яка* з заданих умов `true`.

Наприклад:

```js run
let hour = 9;

*!*
if (hour < 10 || hour > 18) {
*/!*
  alert( 'Офіс зачинений.' );
}
```

Ми можемо передавати більше умов:

```js run
let hour = 12;
let isWeekend = true;

if (hour < 10 || hour > 18 || isWeekend) {
  alert( 'Офіс зачинений.' ); // це вихідні
}
```

<<<<<<< HEAD
## АБО знаходить перше правдиве значення
=======
## OR "||" finds the first truthy value
>>>>>>> 34e9cdca3642882bd36c6733433a503a40c6da74

Описана вище логіка дещо класична. Тепер давайте введемо "додаткові" особливості JavaScript.

Розширений алгоритм працює наступним чином.

Дано кілька значень, розділених опертором АБО:

```js
result = value1 || value2 || value3;
```

Оператор АБО `||` робить наступне:

- Обчислює операнди зліва направо.
- Перетворює значення кожного операнда на булеве. Якщо результат `true`, зупиняється і повертає початкове значення цього операнда.
- Якщо всі операнди були обчисленні (тобто усі були `false`), повертає останній операнд.

Значення повертається у первісному вигляді без конвертації.

Іншими словами, ланцюжок з АБО `"||"` повертає перше правдиве значення або останнє, якщо не знайдено правдивого значення.

Наприклад:

```js run
alert( 1 || 0 ); // 1 (1 є правдивим)
alert( true || 'no matter what' ); // (true є правдивим)

alert( null || 1 ); // 1 (1 є першим правдивим значенням)
alert( null || 0 || 1 ); // 1 (перше правдиве значення)
alert( undefined || null || 0 ); // 0 (усі не правдиві, повертає останнє значення)
```

Це призводить до цікавого використання у порівнянни з "чистим, класичним, виключно-булевим АБО".

1. **Отримання першого правдивого значення зі списку змінних або виразів.**

    Уявіть, що у нас є список змінних, які можуть містити дані або бути `null/undefined`. Як ми можемо знайти першу змінну, яка містить дані?

    Ми можемо використати АБО `||`:

    ```js run
    let currentUser = null;
    let defaultUser = "Іван";

    *!*
    let name = currentUser || defaultUser || "unnamed";
    */!*

    alert( name ); // обере "Іван" – перше правдиве значення
    ```

    Якщо і `currentUser`, і `defaultUser` були б не правдивими, `"unnamed"` було б результатом.
2. **Обчислення короткого замикання.**

    Операндами можуть бути не тільки значення, але й довільні вирази. АБО обчислює та перевіряє їх зліва направо. Обчислення припиняється, коли досягається правдиве значення, і значення повертається. Цей процес називається "обчисленням короткого замикання", оскільки він іде якомога коротше зліва направо.

    Це чітко видно, коли вираз, заданий як другий аргумент, має побічний ефект, як присвоєння змінної.

    У наведеному нижче прикладі `x` не присвоюється значення:

    ```js run no-beautify
    let x;

    *!*true*/!* || (x = 1);

    alert(x); // undefined, оскільки (x = 1) не був обчислений
    ```

    Якщо замість цього перший аргумент є `false`, `||` обчислює другий, таким чином виконуючи присвоєння:

    ```js run no-beautify
    let x;

    *!*false*/!* || (x = 1);

    alert(x); // 1
    ```

    Присвоєння — це простий випадок. Можливі побічні ефекти, які не з'являтимуться, якщо обчислення не досяген їх.

    Як ми бачимо, таке використання є "більш коротким способом виконання `if`". Перший операнд перетворюється на булевий. Якщо він false, то обчислюється другий.

    У більшості випадків краще використовувати "звичайний" `if`, щоб код буле легше зрозуміти, але іноді це може бути зручно.

## && (І)

Оператор І представлений двома амперсандами `&&`:

```js
result = a && b;
```

У класичному програмуванні І повертає `true`, якщо обидва оператора є правдивими і `false` у іншому випадку:

```js run
alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
```

Приклад з `if`:

```js run
let hour = 12;
let minute = 30;

if (hour == 12 && minute == 30) {
  alert( 'Час: 12:30' );
}
```

Так само, як з АБО, будь-яке значення дозволено як операнд І:

```js run
if (1 && 0) { // оцінюється як true && false
  alert( "не буде працювати, тому що результат не правдивий" );
}
```


<<<<<<< HEAD
## І шукає перше не правдиве значення
=======
## AND "&&" finds the first falsy value
>>>>>>> 34e9cdca3642882bd36c6733433a503a40c6da74

Дано декілька значень, об'єднаних І:

```js
result = value1 && value2 && value3;
```

Оператор І `&&` робить наступне:

- Обчислює операнди зліва направо.
- Перетворює кожен операнд на булевий. Якщо результат `false`, зупиняється і повертає оригінальне значення того операнда.
- Якщо всі операнди були обчисленні (тобто усі були правдиві), повертає останній операнд.

Іншими словами, І повертає перше не правдиве значення, або останнє значення, якщо жодного не правдивого не було знайдено.

Правила, наведені вище, подібні до АБО. Різниця полягає в тому, що І повертає перше *не правдиве* значення, тоді як АБО повертає перше *правдиве*.

Приклади:

```js run
// якщо перший операнд правдивий,
// І повертає другий операнд:
alert( 1 && 0 ); // 0
alert( 1 && 5 ); // 5

// якщо перший операнд не правдивий,
// І повертає саме його. Другий операнд ігнорується
alert( null && 5 ); // null
alert( 0 && "не важливо" ); // 0
```

Ми також можемо передавати декілька значень поспіль. Подивіться, як повертається перший не правдивий:

```js run
alert( 1 && 2 && null && 3 ); // null
```

Коли всі значення є правдивими, повертається останнє значення:

```js run
alert( 1 && 2 && 3 ); // 3, останнє
```

````smart header="Пріоритет І `&&` є більш високим за АБО `||`"
Пріоритет оператора І `&&` є більш високим за АБО `||`.

Отже, код `a && b || c && d` по суті є таким самим, як би вираз `&&` був у дужках: `(a && b) || (c && d)`.
````

Так само, як АБО, оператор І `&&` може іноді заміняти `if`.

Наприклад:

```js run
let x = 1;

(x > 0) && alert( 'Більше за нуль!' );
```

Дія у правій частині `&&` буде виконуватися, тільки якщо обчислення дійде до неї. Тобто, тільки якщо `(x > 0)` є ічтинним.

Тому, власне, ми маємо аналог для:

```js run
let x = 1;

if (x > 0) {
  alert( 'Більше за нуль!' );
}
```

Варіант з `&&` є коротшим. Але `if` є більш очевидним і зазвичай є більш чтабельним.

Тому ми рекомендуємо використовувати кожну конструкцію за своїм призначенням: використовуємо `if`, якщо нам потрібен if і використовуємо `&&`, якщо нам потрібен І.

## ! (НЕ)

Булевий оператор НЕ представлений знаком оклику `!`.

Синтаксис дуже простий:

```js
result = !value;
```

Оператор приймає один аргумент і виконує наступне:

1. Перетворює операнд на булевий тип: `true/false`.
2. Повертає зворотне значення.

Наприклад:

```js run
alert( !true ); // false
alert( !0 ); // true
```

Подвійний НЕ `!!` іноді використовується для перетворення значення на булевий тип:

```js run
alert( !!"не пустий рядок" ); // true
alert( !!null ); // false
```

Тобто, перший НЕ перетворює значення на булево і повертає зворотне, а другий НЕ інвертує його знову. Зрештою, ми маємо просте перетворення значення на булевий тип.

Є трохи більш детальний спосіб зробити те ж саме -- вбудована функція `Boolean`:

```js run
alert( Boolean("не пустий рядок") ); // true
alert( Boolean(null) ); // false
```

Пріоритет НЕ `!` є навищим з усіх логічних операторів, тому він завжди виконується першим, перед `&&` або `||`.
