# Логічні оператори

У JavaScript існує три логічні оператори: `||` (АБО), `&&` (І), `!` (НЕ).

Хоча вони називаються "логічними", вони можуть бути застосовані до значень будь-якого типу, не тільки булевих. Їх результати також можуть бути будь-якого типу.

Подивимось більш детально.

## || (АБО)

Оператор "АБО" представлений двома символами вертикальної лінії:

```js
result = a || b;
```

У класичному програмуванні логічний АБО призначений для маніпулювання лише булевими значеннями. Якщо будь-який з його аргументів `true`, він повертає `true`, інакше повертає `false`.

У JavaScript оператор більш складніший і потужніший. Але спочатку подивимося, що відбувається з булевими значеннями.

Є чотири можливі логічні комбінації:

```js run
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
```

Як бачимо, результат завжди `true`, за винятком випадку, коли обидва операнда `false`.

Якщо операнд не є булевим, він перетворюється на булевий для обчислення.

Наприклад, число `1` розглядається як `true`, число `0` — як `false`:

```js run
if (1 || 0) { // працює так само, як ( true || false )
  alert( 'правдиво!' );
}
```

У бильшості випадків АБО `||` використовується в операторі `if`, щоб перевірити, чи є *будь-яка* з заданих умов `true`.

Наприклад:

```js run
let hour = 9;

*!*
if (hour < 10 || hour > 18) {
*/!*
  alert( 'Офіс зачинений.' );
}
```

Ми можемо передавати більше умов:

```js run
let hour = 12;
let isWeekend = true;

if (hour < 10 || hour > 18 || isWeekend) {
  alert( 'Офіс зачинений.' ); // це вихідні
}
```

## АБО "||" знаходить перше правдиве значення

Описана вище логіка дещо класична. Тепер давайте введемо "додаткові" особливості JavaScript.

Розширений алгоритм працює наступним чином.

Дано кілька значень, розділених опертором АБО:

```js
result = value1 || value2 || value3;
```

Оператор АБО `||` робить наступне:

- Обчислює операнди зліва направо.
- Перетворює значення кожного операнда на булеве. Якщо результат `true`, зупиняється і повертає початкове значення цього операнда.
- Якщо всі операнди були обчисленні (тобто усі були `false`), повертає останній операнд.

Значення повертається у первісному вигляді без конвертації.

Іншими словами, ланцюжок з АБО `"||"` повертає перше правдиве значення або останнє, якщо не знайдено правдивого значення.

Наприклад:

```js run
alert( 1 || 0 ); // 1 (1 є правдивим)

alert( null || 1 ); // 1 (1 є першим правдивим значенням)
alert( null || 0 || 1 ); // 1 (перше правдиве значення)

alert( undefined || null || 0 ); // 0 (усі не правдиві, повертає останнє значення)
```

Це призводить до цікавого використання, у порівнянні з "чистим, класичним, виключно-булевим АБО".

1. **Отримання першого правдивого значення зі списку змінних або виразів.**

    Наприклад, маємо змінні `firstName`, `lastName` та `nickName`, усі необов'язкові.

    Використаємо АБО `||`, щоб вибрати ту змінну, яка має дані і виведемо її (або `анонімний` якщо немає даних):

    ```js run
    let firstName = "";
    let lastName = "";
    let nickName = "СуперКодер";

    *!*
    alert( firstName || lastName || nickName || "Анонімний"); // СуперКодер
    */!*
    ```

    Якщо всі змінні мали б порожні рядки, тоді показалося слово "Анонімний".

2. **Обчислення короткого замикання.**

    Іншою особливістю оператора АБО `||` є так зване "обчислення короткого замикання".
    
    Це означає, що оператор `||` опрацьовує аргументи доти, доки не досягається перше правдиве значення, після чого це значення негайно повертається, без подальшого опрацювання решти аргументів.
    
    Важливість цієї особливості стає очевидною, коли операнд не проста змінна, а вираз з побічною дією, такі як присвоєння змінної, або виклик функції.

    У наведеному нижче прикладі, виведеться лише друге повідомлення:

    ```js run no-beautify
    *!*true*/!* || alert("не виведеться");
    *!*false*/!* || alert("виведеться");
    ```

    В першому рядку, оператор АБО `||` зупиняє виконання відразу після того, як "побачить" що лівий вираз `true`, тож `alert` не виконається.

    Деколи люди використовують таку конструкцію щоб виконати команди, якщо умова в лівій частині невірна.

## && (І)

Оператор І представлений двома амперсандами `&&`:

```js
result = a && b;
```

У класичному програмуванні І повертає `true`, якщо обидва оператора є правдивими і `false` у іншому випадку:

```js run
alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
```

Приклад з `if`:

```js run
let hour = 12;
let minute = 30;

if (hour == 12 && minute == 30) {
  alert( 'Час: 12:30' );
}
```

Так само, як з АБО, будь-яке значення дозволено як операнд І:

```js run
if (1 && 0) { // оцінюється як true && false
  alert( "не буде працювати, тому що результат не правдивий" );
}
```


## І "&&" шукає перше не правдиве значення

Дано декілька значень, об'єднаних І:

```js
result = value1 && value2 && value3;
```

Оператор І `&&` робить наступне:

- Обчислює операнди зліва направо.
- Перетворює кожен операнд на булевий. Якщо результат `false`, зупиняється і повертає оригінальне значення того операнда.
- Якщо всі операнди були обчисленні (тобто усі були правдиві), повертає останній операнд.

Іншими словами, І повертає перше не правдиве значення, або останнє значення, якщо жодного не правдивого не було знайдено.

Правила, наведені вище, подібні до АБО. Різниця полягає в тому, що І повертає перше *не правдиве* значення, тоді як АБО повертає перше *правдиве*.

Приклади:

```js run
// якщо перший операнд правдивий,
// І повертає другий операнд:
alert( 1 && 0 ); // 0
alert( 1 && 5 ); // 5

// якщо перший операнд не правдивий,
// І повертає саме його. Другий операнд ігнорується
alert( null && 5 ); // null
alert( 0 && "не важливо" ); // 0
```

Ми також можемо передавати декілька значень поспіль. Подивіться, як повертається перший не правдивий:

```js run
alert( 1 && 2 && null && 3 ); // null
```

Коли всі значення є правдивими, повертається останнє значення:

```js run
alert( 1 && 2 && 3 ); // 3, останнє
```

````smart header="Пріоритет І `&&` є більш високим за АБО `||`"
Пріоритет оператора І `&&` є більш високим за АБО `||`.

Отже, код `a && b || c && d` по суті є таким самим, як би вираз `&&` був у дужках: `(a && b) || (c && d)`.
````

````warn header="Не міняйте `if` на || чи &&"
Деколи люди використовують оператор І `&&` як "скорочений варіант `if`".

Наприклад:

```js run
let x = 1;

(x > 0) && alert( 'Більше за нуль!' );
```

Дія у правій частині `&&` буде виконуватися, тільки якщо обчислення дійде до неї. Тобто, тільки якщо `(x > 0)` є ічтинним.

Тому, власне, ми маємо аналог для:

```js run
let x = 1;

if (x > 0) alert( 'Більше за нуль!' );
```

Варіант з `&&` коротший. Але `if` є більш очевидним і зазвичай більш читабельний. Тому ми рекомендуємо використовувати кожну конструкцію за своїм призначенням: використовуємо `if`, якщо нам потрібен if і використовуємо `&&`, якщо нам потрібен І.
````


## ! (НЕ)

Булевий оператор НЕ представлений знаком оклику `!`.

Синтаксис дуже простий:

```js
result = !value;
```

Оператор приймає один аргумент і виконує наступне:

1. Перетворює операнд на булевий тип: `true/false`.
2. Повертає зворотне значення.

Наприклад:

```js run
alert( !true ); // false
alert( !0 ); // true
```

Подвійний НЕ `!!` іноді використовується для перетворення значення на булевий тип:

```js run
alert( !!"не пустий рядок" ); // true
alert( !!null ); // false
```

Тобто, перший НЕ перетворює значення на булево і повертає зворотне, а другий НЕ інвертує його знову. Зрештою, ми маємо просте перетворення значення на булевий тип.

Є трохи більш детальний спосіб зробити те ж саме -- вбудована функція `Boolean`:

```js run
alert( Boolean("не пустий рядок") ); // true
alert( Boolean(null) ); // false
```

Пріоритет НЕ `!` є навищим з усіх логічних операторів, тому він завжди виконується першим, перед `&&` або `||`.
