# Логічні оператори

У JavaScript існує три логічні оператори: `||` (АБО), `&&` (І), `!` (НЕ).

Хоча вони називаються "логічними", вони можуть бути застосовані до значень будь-якого типу, не тільки булевих. Їх результати також можуть бути будь-якого типу.

Подивимось більш детально.

## || (АБО)

Оператор "АБО" представлений двома символами вертикальної лінії:

```js
result = a || b;
```

У класичному програмуванні логічний АБО призначений для маніпулювання лише булевими значеннями. Якщо будь-який з його аргументів `true`, він повертає `true`, інакше повертає `false`.

У JavaScript оператор більш складніший і потужніший. Але спочатку подивимося, що відбувається з булевими значеннями.

Є чотири можливі логічні комбінації:

```js run
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
```

Як бачимо, результат завжди `true`, за винятком випадку, коли обидва операнда `false`.

Якщо операнд не є булевим, він перетворюється на булевий для обчислення.

Наприклад, число `1` розглядається як `true`, число `0` — як `false`:

```js run
if (1 || 0) { // працює так само, як ( true || false )
  alert( 'правдиво!' );
}
```

У бильшості випадків АБО `||` використовується в операторі `if`, щоб перевірити, чи є *будь-яка* з заданих умов `true`.

Наприклад:

```js run
let hour = 9;

*!*
if (hour < 10 || hour > 18) {
*/!*
  alert( 'Офіс зачинений.' );
}
```

Ми можемо передавати більше умов:

```js run
let hour = 12;
let isWeekend = true;

if (hour < 10 || hour > 18 || isWeekend) {
  alert( 'Офіс зачинений.' ); // це вихідні
}
```

## АБО "||" знаходить перше правдиве значення

Описана вище логіка дещо класична. Тепер давайте введемо "додаткові" особливості JavaScript.

Розширений алгоритм працює наступним чином.

Дано кілька значень, розділених опертором АБО:

```js
result = value1 || value2 || value3;
```

Оператор АБО `||` робить наступне:

- Обчислює операнди зліва направо.
- Перетворює значення кожного операнда на булеве. Якщо результат `true`, зупиняється і повертає початкове значення цього операнда.
- Якщо всі операнди були обчисленні (тобто усі були `false`), повертає останній операнд.

Значення повертається у первісному вигляді без конвертації.

Іншими словами, ланцюжок з АБО `"||"` повертає перше правдиве значення або останнє, якщо не знайдено правдивого значення.

Наприклад:

```js run
<<<<<<< HEAD
alert( 1 || 0 ); // 1 (1 є правдивим)
alert( true || 'no matter what' ); // (true є правдивим)

alert( null || 1 ); // 1 (1 є першим правдивим значенням)
alert( null || 0 || 1 ); // 1 (перше правдиве значення)
alert( undefined || null || 0 ); // 0 (усі не правдиві, повертає останнє значення)
=======
alert( 1 || 0 ); // 1 (1 is truthy)

alert( null || 1 ); // 1 (1 is the first truthy value)
alert( null || 0 || 1 ); // 1 (the first truthy value)

alert( undefined || null || 0 ); // 0 (all falsy, returns the last value)
>>>>>>> d35baee32dcce127a69325c274799bb81db1afd8
```

Це призводить до цікавого використання у порівнянни з "чистим, класичним, виключно-булевим АБО".

1. **Отримання першого правдивого значення зі списку змінних або виразів.**

<<<<<<< HEAD
    Уявіть, що у нас є список змінних, які можуть містити дані або бути `null/undefined`. Як ми можемо знайти першу змінну, яка містить дані?

    Ми можемо використати АБО `||`:

    ```js run
    let currentUser = null;
    let defaultUser = "Іван";
=======
    For instance, we have `firstName`, `lastName` and `nickName` variables, all optional.

    Let's use OR `||` to choose the one that has the data and show it (or `anonymous` if nothing set):

    ```js run
    let firstName = "";
    let lastName = "";
    let nickName = "SuperCoder";
>>>>>>> d35baee32dcce127a69325c274799bb81db1afd8

    *!*
    alert( firstName || lastName || nickName || "Anonymous"); // SuperCoder
    */!*
<<<<<<< HEAD

    alert( name ); // обере "Іван" – перше правдиве значення
    ```

    Якщо і `currentUser`, і `defaultUser` були б не правдивими, `"unnamed"` було б результатом.
2. **Обчислення короткого замикання.**

    Операндами можуть бути не тільки значення, але й довільні вирази. АБО обчислює та перевіряє їх зліва направо. Обчислення припиняється, коли досягається правдиве значення, і значення повертається. Цей процес називається "обчисленням короткого замикання", оскільки він іде якомога коротше зліва направо.

    Це чітко видно, коли вираз, заданий як другий аргумент, має побічний ефект, як присвоєння змінної.

    У наведеному нижче прикладі `x` не присвоюється значення:
=======
    ```

    If all variables were falsy, `Anonymous` would show up.

2. **Short-circuit evaluation.**

    Another feature of OR `||` operator is the so-called "short-circuit" evaluation.
>>>>>>> d35baee32dcce127a69325c274799bb81db1afd8

    It means that `||` processes its arguments until the first truthy value is reached, and then the value is returned immediately, without even touching the other argument.

    That importance of this feature becomes obvious if an operand isn't just a value, but an expression with a side effect, such as a variable assignment or a function call.

<<<<<<< HEAD
    alert(x); // undefined, оскільки (x = 1) не був обчислений
    ```

    Якщо замість цього перший аргумент є `false`, `||` обчислює другий, таким чином виконуючи присвоєння:
=======
    In the example below, only the second message is printed:
>>>>>>> d35baee32dcce127a69325c274799bb81db1afd8

    ```js run no-beautify
    *!*true*/!* || alert("not printed");
    *!*false*/!* || alert("printed");
    ```

<<<<<<< HEAD
    Присвоєння — це простий випадок. Можливі побічні ефекти, які не з'являтимуться, якщо обчислення не досяген їх.

    Як ми бачимо, таке використання є "більш коротким способом виконання `if`". Перший операнд перетворюється на булевий. Якщо він false, то обчислюється другий.

    У більшості випадків краще використовувати "звичайний" `if`, щоб код буле легше зрозуміти, але іноді це може бути зручно.
=======
    In the first line, the OR `||` operator stops the evaluation immediately upon seeing `true`, so the `alert` isn't run.

    Sometimes, people use this feature to execute commands only if the condition on the left part is falsy.
>>>>>>> d35baee32dcce127a69325c274799bb81db1afd8

## && (І)

Оператор І представлений двома амперсандами `&&`:

```js
result = a && b;
```

У класичному програмуванні І повертає `true`, якщо обидва оператора є правдивими і `false` у іншому випадку:

```js run
alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
```

Приклад з `if`:

```js run
let hour = 12;
let minute = 30;

if (hour == 12 && minute == 30) {
  alert( 'Час: 12:30' );
}
```

Так само, як з АБО, будь-яке значення дозволено як операнд І:

```js run
if (1 && 0) { // оцінюється як true && false
  alert( "не буде працювати, тому що результат не правдивий" );
}
```


## І "&&" шукає перше не правдиве значення

Дано декілька значень, об'єднаних І:

```js
result = value1 && value2 && value3;
```

Оператор І `&&` робить наступне:

- Обчислює операнди зліва направо.
- Перетворює кожен операнд на булевий. Якщо результат `false`, зупиняється і повертає оригінальне значення того операнда.
- Якщо всі операнди були обчисленні (тобто усі були правдиві), повертає останній операнд.

Іншими словами, І повертає перше не правдиве значення, або останнє значення, якщо жодного не правдивого не було знайдено.

Правила, наведені вище, подібні до АБО. Різниця полягає в тому, що І повертає перше *не правдиве* значення, тоді як АБО повертає перше *правдиве*.

Приклади:

```js run
// якщо перший операнд правдивий,
// І повертає другий операнд:
alert( 1 && 0 ); // 0
alert( 1 && 5 ); // 5

// якщо перший операнд не правдивий,
// І повертає саме його. Другий операнд ігнорується
alert( null && 5 ); // null
alert( 0 && "не важливо" ); // 0
```

Ми також можемо передавати декілька значень поспіль. Подивіться, як повертається перший не правдивий:

```js run
alert( 1 && 2 && null && 3 ); // null
```

Коли всі значення є правдивими, повертається останнє значення:

```js run
alert( 1 && 2 && 3 ); // 3, останнє
```

````smart header="Пріоритет І `&&` є більш високим за АБО `||`"
Пріоритет оператора І `&&` є більш високим за АБО `||`.

Отже, код `a && b || c && d` по суті є таким самим, як би вираз `&&` був у дужках: `(a && b) || (c && d)`.
````

<<<<<<< HEAD
Так само, як АБО, оператор І `&&` може іноді заміняти `if`.
=======
````warn header="Don't replace `if` with || or &&"
Sometimes, people use the AND `&&` operator as a "shorter to write `if`".
>>>>>>> d35baee32dcce127a69325c274799bb81db1afd8

Наприклад:

```js run
let x = 1;

(x > 0) && alert( 'Більше за нуль!' );
```

Дія у правій частині `&&` буде виконуватися, тільки якщо обчислення дійде до неї. Тобто, тільки якщо `(x > 0)` є ічтинним.

Тому, власне, ми маємо аналог для:

```js run
let x = 1;

<<<<<<< HEAD
if (x > 0) {
  alert( 'Більше за нуль!' );
}
```

Варіант з `&&` є коротшим. Але `if` є більш очевидним і зазвичай є більш чтабельним.

Тому ми рекомендуємо використовувати кожну конструкцію за своїм призначенням: використовуємо `if`, якщо нам потрібен if і використовуємо `&&`, якщо нам потрібен І.
=======
if (x > 0) alert( 'Greater than zero!' );
```

Although, the variant with `&&` appears shorter, `if` is more obvious and tends to be a little bit more readable. So we recommend using every construct for its purpose: use `if` if we want if and use `&&` if we want AND.
````

>>>>>>> d35baee32dcce127a69325c274799bb81db1afd8

## ! (НЕ)

Булевий оператор НЕ представлений знаком оклику `!`.

Синтаксис дуже простий:

```js
result = !value;
```

Оператор приймає один аргумент і виконує наступне:

1. Перетворює операнд на булевий тип: `true/false`.
2. Повертає зворотне значення.

Наприклад:

```js run
alert( !true ); // false
alert( !0 ); // true
```

Подвійний НЕ `!!` іноді використовується для перетворення значення на булевий тип:

```js run
alert( !!"не пустий рядок" ); // true
alert( !!null ); // false
```

Тобто, перший НЕ перетворює значення на булево і повертає зворотне, а другий НЕ інвертує його знову. Зрештою, ми маємо просте перетворення значення на булевий тип.

Є трохи більш детальний спосіб зробити те ж саме -- вбудована функція `Boolean`:

```js run
alert( Boolean("не пустий рядок") ); // true
alert( Boolean(null) ); // false
```

Пріоритет НЕ `!` є навищим з усіх логічних операторів, тому він завжди виконується першим, перед `&&` або `||`.
