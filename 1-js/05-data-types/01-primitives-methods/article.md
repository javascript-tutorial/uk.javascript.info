# Методи примітивів
 
JavaScript дозволяє працювати з примітивами (рядок, число, тощо) так, ніби вони об’єкти. Примітиви також забезпечені методами для роботи. Ми вивчимо їх найближчим часом, але спочатку подивимось як воно працює, бо все ж таки примітиви не є об’єктами (і тут ми краще це зрозуміємо).

Розгляньмо різницю між примітивами та об’єктами.

Примітив

- є значенням примітивного типу
- існує 7 типів примітивів: `string`, `number`, `bigint`, `boolean`, `symbol`, `null` та `undefined`.

Об’єкт

- можна зберігати декілька значень як властивості.
- може бути створений за допомогою `{}`, наприклад: `{name: "Іван", age: 30}`. В JavaScript існують й інші об’єкти: функції — це теж об’єкти.

Одна з найкращих особливостей об'єкта - це те, що ми можемо зберігати функцію як одну з його властивостей.

```js run
let john = {
  name: "John",
  sayHi: function() {
    alert("Привіт, друже!");
  }
};

john.sayHi(); // Привіт, друже!
```

Отже, ми створили об’єкт `john` з методом `sayHi`.

Існує багато вбудованих об’єктів які працюють з датами, помилками, елементами HTML і т.д. Вони мають різні властивості і методи.

Але за все потрібно платити!

Об’єкти "важчі", ніж примітиви. Вони вимагають додаткових ресурсів для підтримки внутрішньої обробки.

## Примітив як об’єкт

Маємо парадокс, з яким зустрівся автор JavaScript:

- Є багато речей, які можна було б зробити з примітивом-рядком або числом. Було б дуже добре якби можна було викликати для примітивів відповідні методи.
- Примітиви повинні бути максимально швидкими та легкими.

Рішення, яке він придумав, вийшло трохи незграбним. Та все ж. Ось як це працює в JavaScript:

1. Примітиви залишаються примітивами. В них, як і задумано, є лише одне значення.
2. Але JavaScript дозволяє отримати доступ до методів та властивостей рядків, чисел, булеанів та символів.
3. Для цього створюється спеціальний "об’єкт-обгортка" (англ. object wrapper) з додатковою функціональністю, який потім знищується.

Для кожного примітиву створюється своя "обгортка": `String`, `Number`, `Boolean`, `Symbol` та `BigInt`. Ну й вони містять різні набори методів.

Наприклад: існує такий метод для рядка, як [str.toUpperCase()](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase), який поверне рядок `str` з великими літерами.

Ось як він працює:

```js run
let str = "Привіт";

alert( str.toUpperCase() ); // ПРИВІТ
```

Не складно, так? Ось що саме трапляється в `str.toUpperCase()`:

1. Рядок `str` є примітивом. Тому в момент, коли треба звернутись до його властивості, створюється спеціальний об’єкт, який знає значення рядка і має корисні методи, такі як `toUpperCase()`.
2. Цей метод виконується і повертає новий рядок (який передається в `alert`).
3. Спеціальний об’єкт знищується, і в пам'яті залишається лише сам примітив `str`.

Отже, примітиви можуть надавати методи, але залишаються "легкими".

Рушій JavaScript добре оптимізує цей процес. Він навіть може взагалі пропустити створення додаткового об’єкта-обгортки. Але навіть в таких ситуаціях він поводиться так, наче він той об'єкт-обгортку створив.

Число має свої методи, наприклад: [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) - округлює число до заданої точності:

```js run
let n = 1.23456;

alert( n.toFixed(2) ); // 1.23
```

Ми переглянемо більш конкретні методи у розділах <info:number> та <info:string>.


````warn header="Конструктори `String/Number/Boolean` існують лише для внутрішнього використання"
Деякі мови як от Java дозволяють явно створювати "об’єкт-обгортку" для примітивів, використовуючи їхній синтаксис `new Number(1)` або `new Boolean(false)`.

У JavaScript це також можливо з історичних причин, але надзвичайно **не рекомендується**. Це призведе до непередбачуваних речей.

Наприклад:

```js run
alert( typeof 0 ); // "number"

alert( typeof new Number(0) ); // "object"!
```

В JavaScript об’єкти завжди повертають `true` в `if`, отже ми побачимо `alert`:

```js run
let zero = new Number(0);

if (zero) { // zero є true, тому що це об’єкт
  alert( "zero є true!?!" );
}
```

З іншого боку, використання тих же самих функцій `String/Number/Boolean`, але без `new` попереду -- це абсолютно розумно і корисно. Без `new` ці функції перетворюють значення у відповідний тип: рядок, число або булеве значення (яке буде примітивом).

Наприклад, це цілком правильно:

```js
let num = Number("123"); // конвертує рядок в число
```
````


````warn header="null/undefined не мають методів"
Примітиви `null` і `undefined` є винятками. Вони не мають відповідних "об’єктів-обгорток" і не забезпечені ніякими методами. Ми можемо назвати їх "найбільш примітивними".

Спроба доступу до властивості такого значення дасть помилку:

```js run
alert(null.test); // помилка
````

## Підсумки

- Примітиви (крім `null` і `undefined`) забезпечені багатьма корисними методами. Ми вивчимо їх у наступних розділах.
- Формально, ці методи працюють через тимчасові об’єкти, але двигун JavaScript оптимізовано для швидкого виконання цих операцій, тому нам не треба хвилюватися.
