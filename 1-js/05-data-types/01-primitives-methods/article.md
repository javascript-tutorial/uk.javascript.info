# Методи примітивів
 
JavaScript дозволяє працювати з примітивами (рядок, число, тощо) ніби вони об’єкти. Примітиви також надають методи для роботи. Ми вивчимо їх найближчим часом, але спочатку подивимось як воно працює, тому що примітиви не є об’єктами (і тут ми зробимо це ще більш зрозумілим).

Розгляньмо різницю між примітивами та об’єктами.

Примітив

- є значенням примітивного типу
- існує 7 типів примітивів: `string`, `number`, `bigint`, `boolean`, `symbol`, `null` та `undefined`.

Об’єкт

- можна зберігати декілька значень як властивості.
- може бути створений за допомогою `{}`, наприклад: `{name: "Іван", age: 30}`. В JavaScript існують й інші об’єкти: функції — це теж об’єкти.

Одна з кращих особливостей об'єкта - це те, що ми можемо зберігати функцію як одну з його властивостей.

```js run
let john = {
  name: "John",
  sayHi: function() {
    alert("Привіт, друже!");
  }
};

john.sayHi(); // Привіт, друже!
```

Отже, ми створили об’єкт `john` з методом `sayHi`.

Існує багато вбудованих об’єктів які працюють з датами, помилками, елементами HTML і т.д. Вони мають різні властивості і методи.

Але за все потрібно платити!

Об’єкти "важчі", ніж примітиви. Вони вимагають додаткових ресурсів для підтримки внутрішньої обробки.

## Примітив як об’єкт

Маємо парадокс, з яким зустрівся автор JavaScript:

- Є багато речей, які можна було б зробити з примітивом-рядком або числом. Було б дуже добре отримати доступ до цих методів.
- Примітиви повинні бути максимально швидкими та легкими.

Рішення, яке він придумав, вийшло трохи незграбним. Але вийшло як вийшло:

1. Примітиви залишаються примітивами. В них є лише одне значення, як і задумано.
2. JavaScript дозволяє отримати доступ до методів та властивостей рядків, чисел, булеанів та символів.
3. Для цього створюється спеціальний "об’єкт-обгортка" (англ. object wrapper) з додатковою функціональністю, який потім знищується.

Для кожного примітиву створюється своя "обгортка": `String`, `Number`, `Boolean`, `Symbol` та `BigInt`. Ну й вони містять різні набори методів.

Наприклад: існує такий метод для рядка, як [str.toUpperCase()](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase), який поверне рядок `str` з великими літерами.

Ось як він працює:

```js run
let str = "Привіт";

alert( str.toUpperCase() ); // ПРИВІТ
```

Не складно, так? Ось що саме трапляється в `str.toUpperCase()`:

1. Рядок `str` є примітивом. Тому в момент коли треба звернутись до його властивості створюється спеціальний об’єкт, який знає значення рядка і має корисні методи, такі як `toUpperCase()`.
2. Цей метод виконується і повертає новий рядок (який передається в `alert`).
3. Спеціальний об’єкт знищується, залишаючи в пам'яті лише примітив `str`.

Отже, примітиви можуть надавати методи, але залишаються "легкими".

Рушій JavaScript добре оптимізує цей процес. Він навіть може пропустити створення додаткового об’єкта-обгортки взагалі. Але навіть в таких ситуаціях він поводиться так, наче він той об'єкт-обгортку створює.

Число має свої методи, наприклад: [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) - округлює число до заданої точності:

```js run
let n = 1.23456;

alert( n.toFixed(2) ); // 1.23
```

Ми переглянемо більш конкретні методи у розділах <info:number> та <info:string>.


````warn header="Конструктори `String/Number/Boolean` існують лише для внутрішнього використання"
Деякі мови як от Java дозволяють явно створювати "об’єкт-обгортку" для примітивів, використовуючи їхній синтаксис `new Number(1)` або `new Boolean(false)`.

У JavaScript це також можливо з історичних причин, але надзвичайно **не рекомендується**. Це призведе до непередбачуваних речей.

Наприклад:

```js run
alert( typeof 0 ); // "number"

alert( typeof new Number(0) ); // "object"!
```

В JavaScript об’єкти завжди повертають `true` в `if`, отже ми побачимо `alert`:

```js run
let zero = new Number(0);

if (zero) { // zero є true, тому що це об’єкт
  alert( "zero є true!?!" );
}
```

З іншого боку, використання тих же самих функцій `String/Number/Boolean`, але без `new` попереду є абсолютно розумно і корисно. Ці функції перетворюють значення у відповідний тип: рядок, число або булеве значення (яке буде примітивом).

Наприклад, це цілком правильно:

```js
let num = Number("123"); // конвертує рядок в число
```
````


````warn header="null/undefined не мають методів"
Примітиви `null` і `undefined` є винятковими. Вони не мають відповідних "об’єктів-обгорток" і не надають ніяких методів. Ми можемо назвати їх "найпримітивнішими".

Спроба доступу до властивості такого значення дасть помилку:

```js run
alert(null.test); // помилка
````

## Підсумки

- Примітиви (крім `null` і `undefined`) забезпечені багатьма корисними методами. Ми вивчимо їх у наступних розділах.
- Формально, ці методи працюють через тимчасові об’єкти, але двигун JavaScript оптимізовано для швидкого виконання цих операцій, тому нам не треба хвилюватися.
