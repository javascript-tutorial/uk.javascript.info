# Методи масивів

Масиви пропонують безліч методів. Щоб було простіше, в цьому розділі вони розбиті на групи.

## Додавання/видалення елементів

Ми вже знаємо методи, які додають чи видаляють елементи з початку чи з кінця:

- `arr.push(...items)` -- додає елементи до кінця,
- `arr.pop()` -- видаляє елемент з кінця,
- `arr.shift()` -- видаляє елемент з початку,
- `arr.unshift(...items)` -- додає елементи в початок.

Розглянемо й інші.

### splice

Як видалити елемент з масиву?

Масиви є об’єктами, тому ми можемо спробувати використати `delete`:

```js run
let arr = ["I", "go", "home"];

delete arr[1]; // видалимо "go"

alert( arr[1] ); // undefined

// тепер arr = ["I",  , "home"];
alert( arr.length ); // 3
```

Начебто, елемент був видалений, але при перевірці виявляється, що масив все ще має 3 елементи  `arr.length == 3`.

Це нормально, тому що все, що робить `delete obj.key` -- це видаляє значення за ключем `key`. Це нормально для обʼєктів, але для масивів ми звичайно ж хочемо, щоб інші елементи змістились і зайняли місце, яке звільнилося. Ми очікуємо, що масив стане коротшим.

Тому слід застосовувати спеціальні методи.

Метод [arr.splice](mdn:js/Array/splice) -- це універсальний «швейцарський ніж» для роботи з масивами. Вміє все: додавати, видаляти і замінювати елементи.

Його синтаксис:

```js
arr.splice(start[, deleteCount, elem1, ..., elemN])
```

Він змінює `arr` починаючи з позиції `start`: видаляє `deleteCount` елементів і вставляє `elem1, ..., elemN` на їх місце. І повертає масив з видалених елементів.

Цей метод легко зрозуміти на прикладах.

Почнемо з видалення:

```js run
let arr = ["I", "study", "JavaScript"];

*!*
arr.splice(1, 1); // з індексу 1 видалимо 1 елемент
*/!*

alert( arr ); // ["I", "JavaScript"]
```

Легко, правда? Починаючи з індексу `1`, він видалив `1`  елемент.

У наступному прикладі ми видаляємо 3 елементи та замінюємо їх двома іншими:

```js run
let arr = [*!*"I", "study", "JavaScript",*/!* "right", "now"];

// видалимо 3 перших елементи і замінимо їх іншими
arr.splice(0, 3, "Let's", "dance");

alert( arr ) // отримаєм [*!*"Let's", "dance"*/!*, "right", "now"]
```

Тут ми бачимо, що `splice` повертає масив видалених елементів:

```js run
let arr = [*!*"I", "study",*/!* "JavaScript", "right", "now"];

// видалимо 2 перших елементи
let removed = arr.splice(0, 2);

alert( removed ); // "I", "study" <-- масив видалених елементів
```

Метод `splice` також може вставляти елементи без будь-яких видалень. Для цього нам потрібно встановити значення `0` для `deleteCount`:

```js run
let arr = ["I", "study", "JavaScript"];

// починаючи з індекса 2
// видалимо 0 елементів
// вставимо "complex" та "language"
arr.splice(2, 0, "complex", "language");

alert( arr ); // "I", "study", "complex", "language", "JavaScript"
```

````smart header="Дозволяються відʼємні індекси"
Тут, як і в інших методах масиву допускаються відʼємні індекси. Вони дозволяють почати відлік елементів з кінця. Наприклад:

```js run
let arr = [1, 2, 5];

// починаючи з індексу -1 (перед останнім елементом)
// видалимо 0 елементів,
// вставимо значення 3 та 4
arr.splice(-1, 0, 3, 4);

alert( arr ); // 1,2,3,4,5
```
````

### slice

Метод [arr.slice](mdn:js/Array/slice) набагато простіший, ніж схожий на нього `arr.splice`.

Його синтаксис:

```js
arr.slice([start], [end])
```

Він повертає новий масив, копіюючи до нього всі елементи від індексу `start` до `end` (не включаючи `end`). І `start`, і `end` можуть бути відʼємними. В такому випадку відлік буде здійснюватися з кінця масиву.

Він подібний до рядкового методу `str.slice`, але замість підрядків створює підмасиви.

Наприклад:

```js run
let arr = ["t", "e", "s", "t"];

alert( arr.slice(1, 3) ); // e,s (копіює з 1 до 3)

alert( arr.slice(-2) ); // s,t (копіює з -2 до кінця)
```

Можна викликати `slice` і взагалі без аргументів. `arr.slice()` створить копію масиву `arr`. Це часто використовують, щоб створити копію масиву для подальших перетворень, які не повинні змінювати вихідний масив.

### concat

Метод [arr.concat](mdn:js/Array/concat) створює новий масив, в який копіює дані з інших масивів та додаткові значення.

Його синтаксис:

```js
arr.concat(arg1, arg2...)
```

Він приймає будь-яку кількість аргументів -- масивів або значень.

Результатом є новий масив, що містить елементи з `arr`, потім` arg1`, `arg2` тощо.

Якщо аргумент `argN` є масивом, то всі його елементи копіюються. В іншому випадку буде скопійовано сам аргумент.

Наприклад:

```js run
let arr = [1, 2];

// створимо масив з: arr і [3,4]
alert( arr.concat([3, 4]) ); // 1,2,3,4

// створимо масив з: arr, [3,4] і [5,6]
alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6

// створимо масив з: arr і [3,4], також добавимо значення 5 і 6
alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6
```

Зазвичай він просто копіює елементи з масивів. Інші обʼєкти, навіть якщо вони виглядають як масиви, додаються як є:

```js run
let arr = [1, 2];

let arrayLike = {
  0: "something",
  length: 1
};

alert( arr.concat(arrayLike) ); // 1,2,[object Object]
```

... Але якщо обʼєкт має спеціальну властивість `Symbol.isConcatSpreadable`, то він обробляється `concat` як масив: замість нього додаються його числові властивості. Для коректної обробки в обʼєкті повинні бути числові властивості та length:

```js run
let arr = [1, 2];

let arrayLike = {
  0: "something",
  1: "else",
*!*
  [Symbol.isConcatSpreadable]: true,
*/!*
  length: 2
};

alert( arr.concat(arrayLike) ); // 1,2,something,else
```

## Перебір: forEach

Метод [arr.forEach](mdn:js/Array/forEach) дозволяє запускати функцію для кожного елемента масиву..

Його синтаксис:
```js
arr.forEach(function(item, index, array) {
  // ... робимо щось з item
});
```

Наприклад, цей код виведе на екран кожен елемент масиву:

```js run
// для кожного елементу викликається alert
["Bilbo", "Gandalf", "Nazgul"].forEach(alert);
```

А цей до того ж розповість і про свою позицію в масиві:

```js run
["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
  alert(`${item} має позицію ${index} в масиві ${array}`);
});
```

Результат функції (якщо вона взагалі щось повертає) відкидається і ігнорується.


## Пошук в масиві

Далі розглянемо методи, які допоможуть знайти що-небудь в масиві.

### indexOf/lastIndexOf та includes

Методи [arr.indexOf](mdn:js/Array/indexOf) та [arr.includes](mdn:js/Array/includes) мають однаковий синтаксис і роблять по суті те ж саме, що і їх рядкові аналоги, але працюють з елементами замість символів:

- `arr.indexOf(item, from)` -- шукає `item`, починаючи з індексу `from`, і повертає індекс, на якому був знайдений шуканий елемент, в іншому випадку `-1`.
- `arr.includes(item, from)` -- шукає `item`, починаючи з індексу `from`, і повертає `true`, якщо пошук успішний.

Зазвичай ці методи використовуються лише з одним аргументом: `item` для пошуку. Типово пошук відбувається з самого початку.

Наприклад:

```js run
let arr = [1, 0, false];

alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1

alert( arr.includes(1) ); // true
```

Зверніть увагу, що метод `indexOf` використовує суворе порівняння `===`. Таким чином, якщо ми шукаємо `false`, він знаходить саме `false`, але не нуль.

Якщо ми хочемо перевірити наявність `item` в массиві, і нема потреби знати його точний індекс, тоді краще використати `arr.includes`.

Метод [arr.lastIndexOf](mdn:js/Array/lastIndexOf) такий самий, як `indexOf`, але шукає з права наліво.

```js run
let fruits = ['Apple', 'Orange', 'Apple']

alert( fruits.indexOf('Apple') ); // 0 (перший Apple)
alert( fruits.lastIndexOf('Apple') ); // 2 (останній Apple)
```

````smart header="Метод `includes` правильно обробляє `NaN`"
Незначною, але вартою уваги властивістю `includes` є те, що він правильно обробляє `NaN`, на відміну від `indexOf`:

```js run
const arr = [NaN];
alert( arr.indexOf(NaN) ); // -1 (повинен бути 0, але === перевірка на рівність не працює з NaN)
alert( arr.includes(NaN) );// true (вірно)
```
Це тому, що `includes` було додано до JavaScript набагато пізніше і він використовує набагато актуальніші алгоритми.
````

### find і findIndex/findLastIndex

Уявіть, що у нас є масив обʼєктів. Як нам знайти обʼєкт, який відповідає певній умові? 

Тут стане в нагоді метод [arr.find(fn)](mdn:js/Array/find). 

Його синтаксис такий:
```js
let result = arr.find(function(item, index, array) {
  // якщо функція поверне true - повертається поточний елемент і перебір закінчується 
  // якщо всі ітерації виявилися помилковими, повертається undefined
});
```

Функція викликається по черзі для кожного елемента масиву:

- `item` -- черговий елемент масиву.
- `index` -- індекс цього елемента.
- `array` -- сам масив.

Якщо функція повертає `true`, пошук припиняється і повертається `item`. Якщо ж функція-колбек ні при якому з елементів не повернула true, тобто якщо об'єкта, який би відповідав нашій умові не знайдено, то метод `.find` повертає `undefined`.

Наприклад, у нас є масив користувачів, кожен з яких має поля `id` та `name`. Давайте знайдемо той де `id == 1`:

```js run
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

let user = users.find(item => item.id == 1);

alert(user.name); // John
```

У реальному житті масиви обʼєктів використовуються дуже часто, тому метод `find` вкрай корисний.

Зверніть увагу, що в даному прикладі ми передаємо в `find` функцію `item => item.id == 1`, з одним аргументом. Це досить поширене явище. Інші аргументи цієї функції використовуються рідко.

Метод [arr.findIndex](mdn:js/Array/findIndex) -- працює по суті так само. Але повертає не сам елемент, а індекс, на якому був знайдений елемент. А якщо нічого не знайдено, то повертає `-1`.

Метод [arr.findLastIndex](mdn:js/Array/findLastIndex) схожий на `findIndex`, але шукає справа наліво, подібно до `lastIndexOf`.

Ось приклад:

```js run
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"},
  {id: 4, name: "John"}
];

// Знайдемо індекс першого John
alert(users.findIndex(user => user.name == 'John')); // 0

// Знайдемо індекс останнього John
alert(users.findLastIndex(user => user.name == 'John')); // 3
```

### filter

Метод `find` повертає лише один елемент, на якому функція-колбек поверне `true`.

На той випадок, якщо знайдених елементів може бути багато, передбачений метод [arr.filter(fn)](mdn:js/Array/filter).

Синтаксис цього методу схожий з `find`, але `filter` повертає масив з усіма елементами, які відповідають умові:

```js
let results = arr.filter(function(item, index, array) {
  // якщо true - елемент додається до масиву з результатом, і перебір продовжується. По закінченню повертається масив з результатами.
  // якщо ні один з елементів не відповідає умові, то повертається порожній масив.
});
```

Наприклад:

```js run
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

// повертає масив перших двох користувачів
let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2
```

## Перетворення масиву

Перейдемо до методів перетворення і впорядкування масиву.

### map

Метод [arr.map](mdn:js/Array/map) є одним з найбільш корисних і часто використовуваних.

Він викликає функцію для кожного елемента масиву і повертає масив результатів виконання цієї функції. 

Синтаксис:

```js
let result = arr.map(function(item, index, array) {
  // повертається нове значення замість елемента
});
```

Наприклад, тут ми перетворюємо кожен елемент на його довжину:

```js run
let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
alert(lengths); // 5,7,6
```

### sort(fn)

Виклик [arr.sort()](mdn:js/Array/sort) сортує масив "на місці", змінюючи в ньому порядок елементів. 

Він повертає відсортований масив, але зазвичай повернене значення ігнорується, оскільки змінюється сам `arr`.

Наприклад:

```js run
let arr = [ 1, 2, 15 ];

// метод сортує вміст arr
arr.sort();

alert( arr );  // *!*1, 15, 2*/!*
```

Чи не помітили нічого дивного в цьому прикладі?

Порядок став 1, 15, 2. Це неправильно! Але чому?

**За замовчуванням елементи сортуються як рядки.**

Буквально, елементи перетворюються в рядки при порівнянні. Для рядків застосовується лексикографічний порядок, і дійсно виходить, що `"2"> "15"`.

Щоб використовувати наш власний порядок сортування, нам потрібно надати функцію аргументом в `arr.sort()`. 

Функція має порівняти два довільних значення та повернути:

```js
function compare(a, b) {
  if (a > b) return 1; // якщо перше значення більше за друге
  if (a == b) return 0; // якщо значення рівні
  if (a < b) return -1; // якщо перше значення меньше за друге
}
```

Наприклад, для сортування чисел:

```js run
function compareNumeric(a, b) {
  if (a > b) return 1;
  if (a == b) return 0;
  if (a < b) return -1;
}

let arr = [ 1, 2, 15 ];

*!*
arr.sort(compareNumeric);
*/!*

alert(arr);  // *!*1, 2, 15*/!*
```

Тепер все працює як треба.  

Давайте відволічемось і подумаємо, що ж відбувається. Згаданий раніше масив `arr` може бути масивом з чим-завгодно, вірно? Він може містити числа, рядки, обʼєкти або щось ще. У нас є набір якихось елементів. Щоб впорядкувати його, нам потрібна функція, яка визначає порядок, яка знає, як порівнювати його елементи. За замовчуванням елементи сортуються як рядки.

Метод `arr.sort(fn)` реалізує загальний алгоритм сортування. Нам не потрібно піклуватися про те, як він працює всередині (в більшості випадків це оптимізоване [швидке сортування](https://en.wikipedia.org/wiki/Quicksort) чи [Timsort](https://en.wikipedia.org/wiki/Timsort)). Реалізується прохід по масиву, порівнюються його елементи за допомогою наданої функції і змінюється їх порядок. Все, що треба від нас - це надати `fn`, яка робить це порівняння.

До речі, якщо ми коли-небудь захочемо дізнатися, які елементи порівнюються -- ніщо не заважає нам вивести їх на екран:

```js run
[1, -2, 15, 2, 0, 8].sort(function(a, b) {
  alert( a + " <> " + b );
  return a - b;
});
```

В процесі роботи алгоритм може порівнювати елемент з іншими по кілька разів, але він намагається зробити якомога менше порівнянь.

````smart header="Функція порівняння може повернути будь-яке число"
Насправді від функції порівняння потрібно будь-яке позитивне число, щоб сказати «більше», і негативне число, щоб сказати «менше». 

Це дозволяє писати коротші функції:

```js run
let arr = [ 1, 2, 15 ];

arr.sort(function(a, b) { return a - b; });

alert(arr);  // *!*1, 2, 15*/!*
```
````

````smart header="Краще використовувати стрілочні функції"
Памʼятаєте [стрілкові функції](info:arrow-functions-basics)? Можна використовувати їх тут для того, щоб сортування виглядало більш акуратним:

```js
arr.sort( (a, b) => a - b );
```

Працюватиме точно так, як і довша версія вище.
````

````smart header="Використовуйте `localeCompare` для рядків"
Памʼятаєте алгоритм порівняння [рядків](info:string#correct-comparisons)? За замовчуванням він порівнює літери за їх кодами.

Для багатьох алфавітів краще використовувати метод `str.localeCompare` для правильного сортування літер, таких як `Ö`.

Наприклад, давайте відсортуємо кілька країн німецькою мовою:

```js run
let countries = ['Österreich', 'Andorra', 'Vietnam'];

alert( countries.sort( (a, b) => a > b ? 1 : -1) ); // Andorra, Vietnam, Österreich (не правильно)

alert( countries.sort( (a, b) => a.localeCompare(b) ) ); // Andorra,Österreich,Vietnam (правильно!)
```
````

### reverse

Метод [arr.reverse](mdn:js/Array/reverse) змінює порядок елементів в `arr` на зворотний.

Наприклад:

```js run
let arr = [1, 2, 3, 4, 5];
arr.reverse();

alert( arr ); // 5,4,3,2,1
```

Він також повертає масив `arr` зі зміненим порядком елементів.

### split та join

Ситуація з реального життя. Ми пишемо додаток для обміну повідомленнями, і відвідувач вводить імена тих, кому його відправити, через кому: Васько, Ярик, Марійка. Але нам то набагато зручніше працювати з масивом імен, ніж з одним рядком. Як отримати масив?

Метод [str.split(delim)](mdn:js/String/split) саме це і робить. Він розбиває рядок на масив по заданому роздільнику `delim` (з англ. deliminator - роздільник).

У прикладі нижче таким роздільником є ​​рядок з коми та пропуску.

```js run
let names = 'Васько, Ярик, Марійка';

let arr = names.split(', ');

for (let name of arr) {
  alert( `A message to ${name}.` ); // Повідомлення отримають: Васько (і інші імена)
}
```

У методу split є необовʼязковий другий числовий аргумент -- обмеження на кількість елементів в масиві. Якщо їх більше, ніж вказано, то залишок масиву буде відкинутий. На практиці це рідко використовується:

```js run
let arr = 'Васько, Ярик, Марійка, Івасик'.split(', ', 2);

alert(arr); // Васько, Ярик
```

````smart header="Розбивка на букви"
Виклик `split(s)` з порожнім аргументом `s` розбиває рядок на масив букв:

```js run
let str = "test";

alert( str.split('') ); // t,e,s,t
```
````

Виклик [arr.join(glue)](mdn:js/Array/join) робить в точності протилежне split. Він створює рядок з елементів `arr`, вставляючи `glue` між ними (з англ. glue - клей).

Наприклад:

```js run
let arr = ["Васько", "Ярик", "Марійка"];

let str = arr.join(';'); // обʼєднуємо масив в рядок за допомогою ";"

alert( str ); // Васько;Ярик;Марійка
```

### reduce/reduceRight

Якщо нам потрібно перебрати масив -- ми можемо використовувати `forEach`, `for` або `for..of`.

Якщо нам потрібно перебрати масив і повернути дані для кожного елемента -- ми використовуємо `map`.

Методи [arr.reduce](mdn:js/Array/reduce) та [arr.reduceRight](mdn:js/Array/reduceRight) схожі на методи вище, але вони трохи складніші. Вони використовуються для обчислення якогось одного значення на основі всього масиву.

Синтаксис:

```js
let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);
```

Функція застосовується по черзі до всіх елементів масиву і «переносить» свій результат на наступний виклик.

Аргументи:

- `accumulator` -- (з англ. накопичувач) результат попереднього виклику цієї функції. При першому виклику дорівнює `initial`(якщо `initial` переданий),
- `item` -- черговий елемент масиву,
- `index` -- індекс чергового елемента,
- `array` -- сам масив.

При виконанні функції результат її попереднього виклику передається на наступний виклик в якості першого аргумента.

Зрозуміти простіше, якщо думати про перший аргумент як про «накопичував» результатів попередніх викликів функції. Після закінчення він стає результатом `reduce`.

Звучить складно?

Цей метод найпростіше зрозуміти на прикладі.

Тут ми отримаємо суму всіх елементів масиву лише одним рядком:

```js run
let arr = [1, 2, 3, 4, 5];

let result = arr.reduce((sum, current) => sum + current, 0);

alert(result); // 15
```

Тут ми використовували найбільш поширений варіант `reduce`, який використовує тільки 2 аргументи.

Давайте детальніше розберемо, як він працює. 

1. При першому запуску `sum` дорівнює `initial` (останній аргумент `reduce`), тобто `0`. А `current` -- перший елемент масиву, рівний `1`. Таким чином, після першого запуску значення `sum` стає `1`.
2. При другому запуску накопичувач `sum` уже дорівнює `1`, і до нього ми додаємо другий елемент масиву (`2`). Таким чином, після другого запуску значення `sum` стає `2`.
3. При третьому запуску `sum` дорівнює `3`. І до нього ми додаємо наступний елемент, і так далі...

Потік обчислень виходить такий:

![](reduce.svg)

У вигляді таблиці, де кожен рядок -- виклик функції на черговому елементі масиву:

|   |`sum`|`current`|результат|
|---|-----|---------|---------|
|перший виклик|`0`|`1`|`1`|
|другий виклик|`1`|`2`|`3`|
|третій виклик|`3`|`3`|`6`|
|четвертий виклик|`6`|`4`|`10`|
|пʼятий виклик|`10`|`5`|`15`|

Тут чітко видно, як результат попереднього виклику передається в перший аргумент наступного.

Ми також можемо не задавати початкове (англ. initial) значення:

```js run
let arr = [1, 2, 3, 4, 5];

// прибрано початкове значення (немає 0 в кінці)
let result = arr.reduce((sum, current) => sum + current);

alert( result ); // 15
```

Результат той самий. Це тому, що при відсутності `initial` в якості першого значення береться перший елемент масиву, а перебір стартує з другого. 

Таблиця розрахунків така ж, як і вище, просто без першого рядка.

Але таке використання вимагає неймовірної обережності. Якщо масив порожній, то виклик `reduce` без початкового значення видасть помилку.

Ось приклад:

```js run
let arr = [];

// Error: Reduce of empty array with no initial value 
// якби існувало початкове значення, reduce повернув би його при порожньому масиві.
arr.reduce((sum, current) => sum + current);
```

Тому рекомендується завжди вказувати початкове значення. 

Метод [arr.reduceRight](mdn:js/Array/reduceRight) працює аналогічно, але проходить по масиву справа наліво.

## Array.isArray

Масиви не мають окремого типу в Javascript. Вони засновані на обʼєктах. 

Тому `typeof` не може відрізнити простий обʼєкт від масиву:

```js run
alert(typeof {}); // обʼєкт
alert(typeof []); // також обʼєкт
```

...Але масиви використовуються настільки часто, що для цього придумали спеціальний метод: [Array.isArray(value)](mdn:js/Array/isArray). Він повертає `true`, якщо `value` -- це масив, і `false` якщо ні.

```js run
alert(Array.isArray({})); // false

alert(Array.isArray([])); // true
```

## Більшість методів підтримують "thisArg"

Майже всі методи масиву, які викликають функції -- такі як `find`, `filter`, `map`, за винятком методу `sort`, приймають необовʼязковий параметр `thisArg`.

Цей параметр не пояснювався вище, оскільки дуже рідко використовується, але для кращого розуміння теми ми зобовʼязані його розглянути.

Ось повний синтаксис цих методів:

```js
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg - це необовʼязковий останній аргумент
```

Значення параметра `thisArg` стає `this` для `func`.

Наприклад, ось тут ми використовуємо метод обʼєкта `army` як фільтр, і `thisArg` передає йому контекст:

```js run
let army = {
  minAge: 25,
  maxAge: 60,
  canBeBussified(user) {
    return user.age >= this.minAge && user.age <= this.maxAge;
  }
};

let users = [
  {age: 19},
  {age: 26},
  {age: 33},
  {age: 61}
];

*!*
// знайти користувачів, яких можна бусифікувати (для яких army.canBeBussified повертає true)
let soldiers = users.filter(army.canBeBussified, army);
*/!*

alert(soldiers.length); // 2
alert(soldiers[0].age); // 26
alert(soldiers[1].age); // 33
```

Якби ми в прикладі вище використовували просто `users.filter(army.canBeBussified)`, то виклик `army.canBeBussified` був би в режимі окремої функції, з `this=undefined`. Це призвело б до помилки.

Виклик `users.filter(army.canBeBussified, army)` можна замінити на `users.filter(user => army.canBeBussified(user))`, який робить те ж саме. Останній запис використовується навіть частіше, оскільки стрілочна функція більш наочна.

## Підсумки

Шпаргалка з методів масиву:

- Для додавання/видалення елементів:
  - `push(... items)` -- додає елементи до кінця,
  - `arr.pop()` -- дістає елемент з кінця,
  - `arr.shift()` -- дістає елемент з початку,
  - `arr.unshift(...items)` -- додає елементи в початок.
  - `splice(pos, deleteCount, ...items)` -- починаючи з індексу `pos`, видаляє `deleteCount` елементів та вставляє `items`.
  - `slice(start, end)` -- створює новий масив, копіюючи в нього елементи з позиції `start` до `end` (не включаючи `end`).
  - `concat(...items)` -- повертає новий масив: копіює всі члени поточного масиву і додає до нього `items`. Якщо якийсь із `items` є масивом, тоді беруться його елементи.

- Для пошуку серед елементів:
  - `indexOf/lastIndexOf(item, pos)` -- шукає `item`, починаючи з позиції `pos`, і повертає його індекс або `-1`, якщо нічого не знайдено.
  - `includes(value)` -- повертає `true`, якщо в масиві знайдено елемент `value`, або `false` якщо не знайдено.
  - `find/filter(func)` -- фільтрують елементи через функцію і повертають перший/всі елементи, при використинні яких функція повертає `true`. І `undefined`/`[]` якщо таких елементів не знайдено.
  - `findIndex` схожий на `find`, але повертає індекс замість значення. Або `-1` якщо не знайшов.

- Для перебору елементів:
  - `forEach(func)` -- викликає `func` для кожного елемента. Нічого не повертає.

- Для перетворення масиву:
  - `map(func)` -- створює новий масив з результатів виклику `func` для кожного елемента.
  - `sort(func)` -- сортує масив «на місці», а потім повертає його.
  - `reverse()` -- «на місці» змінює порядок елементів на протилежний і повертає змінений масив.
  - `split/join` -- перетворюють рядок в масив і назад.
  - `reduce(func, initial)` -- обчислює накопичуване значення на основі всього масиву, викликаючи `func` для кожного елемента і передаючи проміжний результат між викликами.

- Додатково:
  - `Array.isArray(value)` перевіряє, чи є `value` масивом, якщо так, повертає `true`, і `false` якщо ні.

Зверніть увагу, що методи `sort`, `reverse` та `splice` змінюють поточний масив. 

Вивчених нами методів досить в 99% випадків, але існують і інші.

- [arr.some(fn)](mdn:js/Array/some)/[arr.every(fn)](mdn:js/Array/every) перевіряють масив.

Функція `fn` викликається для кожного елемента масиву, подібно до `map`. Якщо будь-які/усі результати є `true`, повертає `true`, інакше `false`.

Ці методи поводяться приблизно як оператори `||` та `&&`. Якщо `fn` повертає істинне значення, `arr.some()` негайно повертає `true` і припиняє ітерацію по решті елементів. Якщо `fn` повертає хибне значення, `arr.every()` негайно повертає `false` і припиняє ітерацію по решті елементів.

  Ми можемо використовувати `every` для порівняння масивів:
  
  ```js run
  function arraysEqual(arr1, arr2) {
    return arr1.length === arr2.length && arr1.every((value, index) => value === arr2[index]);
  }

  alert( arraysEqual([1, 2], [1, 2])); // true
  ```

- [arr.fill(value, start, end)](mdn:js/Array/fill) -- заповнює масив повторюваними `value`, починаючи з індексу `start` до `end`.

- [arr.copyWithin(target, start, end)](mdn:js/Array/copyWithin) -- копіює свої елементи, починаючи з `start` і закінчуючи `end`, в власну позицію `target` (перезаписучи існуючі).

- [arr.flat(depth)](mdn:js/Array/flat)/[arr.flatMap(fn)](mdn:js/Array/flatMap) -- створює новий, плоский масив з багатовимірного масиву.

Повний список є в [довіднику MDN](mdn:js/Array).

На перший погляд, може здатися, що існує дуже багато різних методів, які досить складно запамʼятати. Але це тільки так здається.

Уважно вивчіть шпаргалку, представлену вище, а потім, щоб попрактикуватися, повирішуйте завдання, запропоновані в цьому розділі. Так ви отримаєте необхідний досвід в правильному використанні методів масиву.

Кожного разу, коли вам буде необхідно щось зробити з масивом, а ви не знаєте як це зробити -- приходьте сюди, дивіться на таблицю і шукайте правильний метод. Приклади допоможуть вам все зробити правильно, і незабаром ви швидко запамʼятайте методи без надмірних зусиль.
