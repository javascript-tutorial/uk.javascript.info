# Відновлюване завантаження файлу

За допомогою методу `fetch` досить легко завантажити файл.

Але як відновити завантаження після втрати з’єднання? Для цього немає вбудованого функціонала, але у нас є все необхідне для його реалізації.

Відновлювані завантаження файлів повинні мати індикацію прогресу, оскільки ми очікуємо завантаження великих файлів. Отже, оскільки `fetch` не дозволяє відстежувати хід завантаження на сервер, ми будемо використовувати [XMLHttpRequest](info:xmlhttprequest).

## Не дуже корисна подія progress

Щоб відновити завантаження, нам потрібно знати, скільки даних було завантажено до втрати з’єднання.

Існує подія `xhr.upload.onprogress`, яка використовується для відстежування ходу завантаження на сервер.

Але, на жаль, вона нам не допоможе відновити завантаження, оскільки ця подія спрацьовує в момент, коли дані *відсилаються*, але чи отримав їх сервер? Браузер цього не знає.

Можливо, дані були буферизовані проксі-сервером локальної мережі, або, можливо, процес сервера просто завершився і не зміг їх обробити, або дані просто загубилися в процесі передачі і не досягли одержувача.

Тому ця подія корисна лише для того, щоб показати гарний індикатор прогресу.

Для відновлення завантаження, нам потрібно *точно* знати кількість байтів, отриманих сервером. І тільки сервер має цю інформацію, тому ми зробимо додатковий запит.

## Алгоритм

1. Спочатку створюємо ідентифікатор файлу, щоб однозначно ідентифікувати файл, який ми збираємося завантажити на сервер:
    ```js
    let fileId = file.name + '-' + file.size + '-' + file.lastModified;
    ```
    Це потрібно, щоб повідомити серверу, для якого саме файлу ми відновлюємо завантаження.

    Якщо змінюється назва, розмір або дата останньої модифікації файлу, `fileId` буде відрізнятися.

2. Надсилаємо запит серверу, щоб дізнатися, скільки байтів вже завантажено, наприклад:
    ```js
    let response = await fetch('status', {
      headers: {
        'X-File-Id': fileId
      }
    });

    // сервер отримав стільки байтів
    let startByte = +await response.text();
    ```

    Це передбачає, що сервер відстежує завантаження файлів за допомогою заголовків `X-File-Id`. Це повинно бути реалізовано на стороні сервера.

    Якщо файл ще не існує на сервері, тоді відповідь сервера має бути `0`

3. Після цього ми можемо використати метод `slice` об’єкта `Blob`, щоб надіслати файл починаючи з байта вказаного в `startByte`:
    ```js
    xhr.open("POST", "upload", true);

    // Ідентифікатор файлу, щоб сервер знав, який файл ми завантажуємо
    xhr.setRequestHeader('X-File-Id', fileId);

    // Байт, починаючи з якого ми відновлюємо завантаження
    xhr.setRequestHeader('X-Start-Byte', startByte);

    xhr.upload.onprogress = (e) => {
      console.log(`Завантажено ${startByte + e.loaded} з ${startByte + e.total}`);
    };

    // файл може бути з input.files[0] або з іншого джерела
    xhr.send(file.slice(startByte));
    ```

    Ми надсилаємо серверу ідентифікатор файлу у заголовку `X-File-Id`, щоб він знав, який саме файл ми завантажуємо, та початковий байт у заголовку `X-Start-Byte`, щоб повідомити, що ми відновлюємо завантаження, а не завантажуємо його спочатку.

    Сервер повинен перевірити свої записи, і якщо було завантаження цього файлу, а також поточний розмір завантаженого файлу точно дорівнює `X-Start-Byte`, то додати дані до нього.


Ось приклад з кодом клієнта і сервера, написаний на Node.js.

На цьому сайті він працює лише частково, оскільки Node.js знаходиться за іншим сервером під назвою Nginx, який буферує завантаження і передає їх у Node.js тільки після повного завершення.

Але ви можете завантажити та запустити його локально для повної демонстрації:

[codetabs src="upload-resume" height=200]

Як бачимо, сучасні мережеві методи за своїми можливостями близькі до файлових менеджерів -- контроль над заголовками, індикатор прогресу, надсилання частин файлу тощо.

Ми можемо реалізувати як відновлюване завантаження файлів, так і багато іншого.
